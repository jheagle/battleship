<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Core system functions
/**
 * Return a curried version of the passed function.
 * The returned function expects the same number of arguments minus the ones provided.
 * fn is the name of the function being curried.
 * @param {function} fn - Receives a function to be curried
 * @returns {function(...[*]): function(...[*])}
 */
const curry = (fn) => {
    let curried = (...args) => args.length >= fn.length ?
        fn(...args) :
        (...a) => curried(...[...args, ...a])
    return curried
}

/**
 * This function is intended to replicate behaviour of the Array.map() function but for Objects.
 * If an array is passed in instead then it will perform standard map(). It is recommended to
 * always use the standard map() function when it is known that the object is actually an array.
 * @param {Object|Array} obj - The Object (or Array) to be mapped
 * @param {function} fn - The function to be processed for each mapped element
 * @param {Object|Array} initObj - Provide some initial return properties to the mapped object
 * @returns {Object|Array}
 */
const mapObject = (obj, fn, initObj = {}) => Array.isArray(obj) ? obj.map((prop, i) => fn.length === 1 ? fn(prop) : fn(prop, i)) : Object.keys(obj).reduce((newObj, curr) => {
    newObj[curr] = fn.length === 1 ? fn(obj[curr]) : fn(obj[curr], curr)
    return newObj
}, initObj)

/**
 * This function is intended to replicate behaviour of the Array.filter() function but for Objects.
 * If an array is passed in instead then it will perform standard filter(). It is recommended to
 * always use the standard filter() function when it is known that the object is actually an array.
 * @param {Object|Array} obj
 * @param {function} fn
 * @param {Object|Array} initObj
 * @returns {Object|Array}
 */
const filterObject = (obj, fn, initObj = {}) => Array.isArray(obj) ? obj.filter((prop, i) => fn.length === 1 ? fn(prop) : fn(prop, i)) : Object.keys(obj).reduce((newObj, curr) => {
    if ((fn.length === 1 ? fn(obj[curr]) : fn(obj[curr], curr))) {
        newObj[curr] = obj[curr]
    } else {
        delete newObj[curr]
    }
    return newObj
}, initObj)

/**
 * This function is intended to replicate behaviour of the Array.reduce() function but for Objects.
 * If an array is passed in instead then it will perform standard reduce(). It is recommended to
 * always use the standard reduce() function when it is known that the object is actually an array.
 * @param {Object|Array} obj
 * @param {function} fn
 * @param {Object|Array} initObj
 * @returns {Object|Array}
 */
const reduceObject = (obj, fn, initObj = {}) => Array.isArray(obj) ? obj.reduce(fn, initObj) : Object.keys(obj).reduce((newObj, curr) => fn(newObj, obj[curr]), initObj)

/**
 * Helper function for testing if the item is an Object or Array that contains properties or elements
 * @param {Object|Array} item
 * @returns {boolean}
 */
const notEmptyObjectOrArray = item => !!((typeof item === 'object' &amp;&amp; Object.keys(item).length) || (Array.isArray(item) &amp;&amp; item.length))

/**
 * A function to use with mapObject or just map which will either return the result
 * of re-running a function or return the original item.
 * Pass in the object to be used with map.
 * Pass in the conditions as a test function: True returns the object; False continues recursion.
 * Pass in the recursive function.
 * Add any other args to that function.
 * @param {Object} obj
 * @param {function} test
 * @param {function} fn
 * @param {...*} [args]
 * @returns {*|function(*=, *)}
 */
const recursiveMap = (obj, test, fn, ...args) => (prop, key) => test(prop, key) ? prop : fn(obj[key], prop, ...args)

/**
 * Tests exceptions to what must be returned as reference vs cloned.
 * @param {Object} obj
 * @param {boolean} [extraTest=false]
 * @returns {boolean}
 */
const cloneRules = (obj, extraTest = false) => (prop, key) => !obj[key] || prop instanceof HTMLElement || key === 'parentItem' || key === 'listenerArgs' || (extraTest ? extraTest(prop, key) : false)

/**
 * A helper for cloneExclusions to simplify that function
 * @param {Object} cloned
 * @param {Object} object
 * @param {Array} parents
 * @param {function} fn
 * @returns {Object|Array}
 */
const cloneExMap = (cloned, object, parents, fn) => mapObject(object, recursiveMap(cloned, cloneRules(cloned, curry(inArray)(parents.concat([object]))), fn, parents.concat([object])))

/**
 * Re-add the Object Properties which cannot be cloned and must be directly copied to the new cloned object
 * WARNING: This is a recursive function.
 * @param {Object} cloned
 * @param {Object} object
 * @param {Array} parents
 * @returns {Object|Array}
 */
const cloneExclusions = (cloned, object, parents = []) => notEmptyObjectOrArray(object) ?
    cloneExMap(cloned, object, parents, cloneExclusions) :
    cloned

/**
 * Exclude cloning the same references multiple times. This ia utility function to be called with JSON.stringify
 * @param {string|number} key
 * @param {*} val
 * @param {Array} [parents=[]]
 * @returns {undefined|*}
 */
const removeCircularReference = (key, val, parents = []) => {
    if (typeof val === 'object') {
        if (inArray(parents, val))
            return undefined
        parents.push(val)
    }
    return val
}

/**
 * Clone objects for manipulation without data corruption, returns a copy of the provided object.
 * @param {Object} object
 * @param {Array} [parents=[]]
 * @returns {Object}
 */
const cloneObject = (object, parents = []) => cloneExclusions(JSON.parse(JSON.stringify(object, (key, val) => removeCircularReference(key, val, parents))), object, parents = [])

/**
 * Merge two objects and provide clone or original on the provided function.
 * The passed function should accept a minimum of two objects to be merged.
 * If the desire is to mutate the input objects, then the function name should
 * have the word 'mutable' in the name (case-insensitive).
 * @param {function} fn
 * @param {Object} obj1
 * @param {Object} obj2
 * @returns {Object}
 */
const mergeObjectsBase = (fn, obj1, obj2) => (notEmptyObjectOrArray(obj2)) ? mapObject(obj2, recursiveMap(obj1, cloneRules(obj1), fn), /mutable/i.test(fn.name) ? obj1 : cloneObject(obj1)) : obj2

/**
 * Perform a deep merge of objects. This will combine all objects and sub-objects,
 * objects having the same attributes will overwrite starting from the end of the argument
 * list and bubbling up to return a merged version of the first object.
 * WARNING: This is a recursive function.
 * @param {...Object} args
 * @returns {Object}
 */
const mergeObjects = (...args) => args.length === 2 ?
    mergeObjectsBase(mergeObjects, args[0], args[1]) :
    args.length === 1 ?
        cloneObject(args[0]) :
        args.reduce(curry(mergeObjectsBase)(mergeObjects), {})

/**
 * Perform a deep merge of objects. This will combine all objects and sub-objects,
 * objects having the same attributes will overwrite starting from the end of the argument
 * list and bubbling up to return the overwritten first object.
 * WARNING: This is a recursive function.
 * WARNING: This will mutate the first object passed in as input
 * @param {...Object} args
 * @returns {Object}
 */
const mergeObjectsMutable = (...args) => args.length === 2 ?
    mergeObjectsBase(mergeObjectsMutable, args[0], args[1]) :
    args.length === 1 ?
        args[0] :
        args.reduce(curry(mergeObjectsBase)(mergeObjectsMutable), {})

/**
 * Generate an array filled with a copy of the provided item or references to the provided item.
 * The length defines how long the array should be.
 * WARNING: This is a recursive function.
 * @param {boolean} useReference
 * @param {*} item
 * @param {number} length
 * @param {Array} [arr=[]]
 * @returns {Array.&lt;*>}
 */
const buildArrayBase = (useReference, item, length, arr = []) => --length > 0 ? buildArrayBase(useReference, (useReference ? item : cloneObject(item)), length, arr.concat([item])) : arr.concat([item])

/**
 * Leverage buildArrayBase to generate an array filled with a copy of the provided item.
 * The length defines how long the array should be.
 * @function buildArray
 * @param {*} item
 * @param {number} length
 * @param {Array} [arr=[]]
 * @returns {Array.&lt;*>}
 */
const buildArray = curry(buildArrayBase)(false)

/**
 * Leverage buildArrayBase to generate an array filled with references to the provided item.
 * The length defines how long the array should be.
 * @function buildArrayOfReferences
 * @param {*} item
 * @param {number} length
 * @param {Array} [arr=[]]
 * @returns {Array.&lt;*>}
 */
const buildArrayOfReferences = curry(buildArrayBase)(true)

/**
 * A simple function to check if an item is in an array
 * @param {Array} arr
 * @param {*} prop
 * @returns {boolean}
 */
const inArray = (arr, prop) => arr.indexOf(prop) >= 0

/**
 * A simple function usable with reduce to get the max or min value
 * @param {boolean} getMax
 * @param {number} num1
 * @param {number} num2
 * @returns {number}
 */
const getMaxOrMin = (getMax, num1, num2) => ((getMax &amp;&amp; num2 > num1) || (!getMax &amp;&amp; num2 &lt; num1)) ? num2 : num1

/**
 * Helper for returning max value
 * @function getMax
 * @param {number} num1
 * @param {number} num2
 * @returns {number}
 */
const getMax = curry(getMaxOrMin)(true)

/**
 * Helper for returning min value
 * @function getMin
 * @param {number} num1
 * @param {number} num2
 * @returns {number}
 */
const getMin = curry(getMaxOrMin)(false)

/**
 * Create a single random number within provided range. And with optional offset,
 * The distance between the result numbers can be adjusted with interval.
 * @param {number} range
 * @param {number} [offset=0]
 * @param {number} [interval=1]
 * @returns {number}
 */
const randomNumber = (range, offset = 0, interval = 1) => (Math.random() * range + offset) * interval

/**
 * Create a single random integer within provide range. And with optional offset,
 * The distance between the result numbers can be adjusted with interval.
 * @param {number} range
 * @param {number} [offset=0]
 * @param {number} [interval=1]
 * @returns {number}
 */
const randomInteger = (range, offset = 0, interval = 1) => (Math.floor(Math.random() * range) + offset) * interval

/**
 * Run Timeout functions one after the other in queue
 * WARNING: This is a recursive function.
 * @param {function} fn
 * @param {number} time
 * @param {...*} args
 * @returns {{id: number, func: function, timeout: number, args: {Array}, result: *}}
 */
const queueTimeout = (fn = {}, time = 0, ...args) => {
    queueTimeout.queue = queueTimeout.queue || []
    queueTimeout.isRunning = queueTimeout.isRunning || false
    let queueItem = {id: 0, func: fn, timeout: time, args: args, result: 0}
    if (fn)
        queueTimeout.queue.push(queueItem)

    if (queueTimeout.queue.length &amp;&amp; !queueTimeout.isRunning) {
        queueTimeout.isRunning = true
        let toRun = queueTimeout.queue.shift()
        toRun.id = setTimeout(() => {
            toRun.result = toRun.func(...toRun.args)
            queueTimeout.isRunning = false
            return queueTimeout(false)
        }, toRun.timeout)
        return toRun
    }
    return queueItem
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="global.html#DOMItem">DOMItem</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appendAllHTML">appendAllHTML</a></li><li><a href="global.html#appendHTML">appendHTML</a></li><li><a href="global.html#appendListeners">appendListeners</a></li><li><a href="global.html#assignListener">assignListener</a></li><li><a href="global.html#bindAllElements">bindAllElements</a></li><li><a href="global.html#bindAllListeners">bindAllListeners</a></li><li><a href="global.html#bindElement">bindElement</a></li><li><a href="global.html#bindListeners">bindListeners</a></li><li><a href="global.html#buildArray">buildArray</a></li><li><a href="global.html#buildArrayBase">buildArrayBase</a></li><li><a href="global.html#buildArrayOfReferences">buildArrayOfReferences</a></li><li><a href="global.html#buildHTML">buildHTML</a></li><li><a href="global.html#cloneExclusions">cloneExclusions</a></li><li><a href="global.html#cloneExMap">cloneExMap</a></li><li><a href="global.html#cloneObject">cloneObject</a></li><li><a href="global.html#cloneRules">cloneRules</a></li><li><a href="global.html#cube">cube</a></li><li><a href="global.html#curry">curry</a></li><li><a href="global.html#documentDOMItem">documentDOMItem</a></li><li><a href="global.html#documentItem">documentItem</a></li><li><a href="global.html#elementChanges">elementChanges</a></li><li><a href="global.html#elementHasAttribute">elementHasAttribute</a></li><li><a href="global.html#filterObject">filterObject</a></li><li><a href="global.html#generateElement">generateElement</a></li><li><a href="global.html#getChildrenByClass">getChildrenByClass</a></li><li><a href="global.html#getChildrenByName">getChildrenByName</a></li><li><a href="global.html#getChildrenFromAttribute">getChildrenFromAttribute</a></li><li><a href="global.html#getMax">getMax</a></li><li><a href="global.html#getMaxOrMin">getMaxOrMin</a></li><li><a href="global.html#getMin">getMin</a></li><li><a href="global.html#getParentsByClass">getParentsByClass</a></li><li><a href="global.html#getParentsByName">getParentsByName</a></li><li><a href="global.html#getParentsFromAttribute">getParentsFromAttribute</a></li><li><a href="global.html#getTopParentItem">getTopParentItem</a></li><li><a href="global.html#inArray">inArray</a></li><li><a href="global.html#initChildren">initChildren</a></li><li><a href="global.html#initRoot">initRoot</a></li><li><a href="global.html#listenerOptions">listenerOptions</a></li><li><a href="global.html#mapObject">mapObject</a></li><li><a href="global.html#matrix">matrix</a></li><li><a href="global.html#mergeObjects">mergeObjects</a></li><li><a href="global.html#mergeObjectsBase">mergeObjectsBase</a></li><li><a href="global.html#mergeObjectsMutable">mergeObjectsMutable</a></li><li><a href="global.html#notEmptyObjectOrArray">notEmptyObjectOrArray</a></li><li><a href="global.html#point">point</a></li><li><a href="global.html#queueTimeout">queueTimeout</a></li><li><a href="global.html#randomInteger">randomInteger</a></li><li><a href="global.html#randomNumber">randomNumber</a></li><li><a href="global.html#recursiveMap">recursiveMap</a></li><li><a href="global.html#reduceObject">reduceObject</a></li><li><a href="global.html#registerListener">registerListener</a></li><li><a href="global.html#registerListeners">registerListeners</a></li><li><a href="global.html#removeChild">removeChild</a></li><li><a href="global.html#removeCircularReference">removeCircularReference</a></li><li><a href="global.html#renderHTML">renderHTML</a></li><li><a href="global.html#retrieveListener">retrieveListener</a></li><li><a href="global.html#square">square</a></li><li><a href="global.html#tile">tile</a></li><li><a href="global.html#updateElement">updateElement</a></li><li><a href="global.html#updateElements">updateElements</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Nov 01 2017 10:55:04 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

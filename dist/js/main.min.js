'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var base = undefined || window || {}
// Core system functions
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Store reference to any pre-existing module of the same name
   * @type {jDomCore|*}
   */
  var previousJDomCore = root.jDomCore || {};

  /**
   * All methods exported from this module are encapsulated within jDomCore.
   * @typedef {Object} jDomCore
   * @property {function} buildArray
   * @property {function} buildArrayOfReferences
   * @property {function} cloneObject
   * @property {function} compare
   * @property {function} compareArrays
   * @property {function} curry
   * @property {function} filterObject
   * @property {function} getMax
   * @property {function} getMaxOrMin
   * @property {function} getMin
   * @property {function} inArray
   * @property {function} mapObject
   * @property {function} mergeObjects
   * @property {function} mergeObjectsMutable
   * @property {function} noConflict
   * @property {function} notEmptyObjectOrArray
   * @property {function} pipe
   * @property {function} queueTimeout
   * @property {function} randomInteger
   * @property {function} randomNumber
   * @property {function} reduceObject
   * @property {function} trace
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {jDomCore}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.jDomCore = previousJDomCore;
      return exportFunctions;
    }
  };
  root.jDomCore = exportFunctions;

  /**
   * Return a curried version of the passed function.
   * The returned function expects the same number of arguments minus the ones provided.
   * fn is the name of the function being curried.
   * @param {function} fn - Receives a function to be curried
   * @returns {function(...[*]): function(...[*])}
   */
  var curry = function curry(fn) {
    var curried = function curried() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return args.length >= fn.length ? fn.apply(undefined, args) : function () {
        for (var _len2 = arguments.length, a = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          a[_key2] = arguments[_key2];
        }

        return curried.apply(undefined, [].concat(args, a));
      };
    };
    return curried;
  };
  exportFunctions.curry = curry;

  /**
   * This was copied from a blog post on Composing Software written by Eric Elliott. The idea is to begin to make this
   * code base somewhat easier to parse and introduce point-free notation.
   * @author Eric Elliott
   * @param {...function} fns - Takes a series of functions have the same parameter, which parameter is also returned.
   * @returns {function(*=): (*|any)}
   */
  exportFunctions.pipe = function () {
    for (var _len3 = arguments.length, fns = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      fns[_key3] = arguments[_key3];
    }

    return function (x) {
      return fns.reduce(function (y, f) {
        return f(y);
      }, x);
    };
  };

  /**
   * Function that produces a property of the new Object, taking three arguments
   * @callback mapCallback
   * @param {*} currentProperty - The current property being processed in the object.
   * @param {string} [currentIndex] - The property name of the current property being processed in the object.
   * @param {Object|Array} [object] - The object map was called upon.
   * @returns {*}
   */

  /**
   * This function is intended to replicate behaviour of the Array.map() function but for Objects.
   * If an array is passed in instead then it will perform standard map(). It is recommended to
   * always use the standard map() function when it is known that the object is actually an array.
   * @param {Object|Array} obj - The Object (or Array) to be mapped
   * @param {mapCallback} fn - The function to be processed for each mapped property
   * @param {Object|Array} [thisArg] - Optional. Value to use as this when executing callback.
   * @returns {Object|Array}
   */
  var mapObject = function mapObject(obj, fn) {
    var thisArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    return Array.isArray(obj) ? obj.map(fn, thisArg) : Object.keys(obj).reduce(function (newObj, curr) {
      newObj[curr] = fn.apply(undefined, _toConsumableArray([obj[curr], curr, obj].slice(0, fn.length || 2)));
      return newObj;
    }, thisArg || {});
  };
  exportFunctions.mapObject = mapObject;

  /**
   * Function is a predicate, to test each property value of the object. Return true to keep the element, false otherwise, taking three arguments:
   * @callback filterCallback
   * @param {*} currentProperty - The current property being processed in the object.
   * @param {string} [currentIndex] - The property name of the current property being processed in the object.
   * @param {Object|Array} [object] - The object filter was called upon.
   * @returns {boolean}
   */

  /**
   * This function is intended to replicate behaviour of the Array.filter() function but for Objects.
   * If an array is passed in instead then it will perform standard filter(). It is recommended to
   * always use the standard filter() function when it is known that the object is actually an array.
   * @param {Object|Array} obj - The Object (or Array) to be filtered
   * @param {filterCallback} fn - The function to be processed for each filtered property
   * @param {Object|Array} [thisArg] - Optional. Value to use as this when executing callback.
   * @returns {Object|Array}
   */
  var filterObject = function filterObject(obj, fn) {
    var thisArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    return Array.isArray(obj) ? obj.filter(fn, thisArg) : Object.keys(obj).reduce(function (newObj, curr) {
      if (fn.apply(undefined, _toConsumableArray([obj[curr], curr, obj].slice(0, fn.length || 2)))) {
        newObj[curr] = obj[curr];
      } else {
        delete newObj[curr];
      }
      return newObj;
    }, thisArg || {});
  };
  exportFunctions.filterObject = filterObject;

  /**
   * Function to execute on each property in the object, taking four arguments:
   * @callback reduceCallback
   * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied (see below).
   * @param {*} currentProperty - The current property being processed in the object.
   * @param {string} [currentIndex] - The index of the current element being processed in the array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   * @param {Object|Array} [object] - The object reduce was called upon.
   * @returns {*}
   */

  /**
   * This function is intended to replicate behaviour of the Array.reduce() function but for Objects.
   * If an array is passed in instead then it will perform standard reduce(). It is recommended to
   * always use the standard reduce() function when it is known that the object is actually an array.
   * @param {Object|Array} obj - The Object (or Array) to be filtered
   * @param {reduceCallback} fn - The function to be processed for each filtered property
   * @param {Object|Array} [initialValue] - Optional. Value to use as the first argument to the first call of the callback. If no initial value is supplied, the first element in the array will be used. Calling reduce on an empty array without an initial value is an error.
   * @returns {Object|Array}
   */
  var reduceObject = function reduceObject(obj, fn) {
    var initialValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : obj[Object.keys(obj)[0]] || obj[0];
    return Array.isArray(obj) ? obj.reduce(fn, initialValue) : Object.keys(obj).reduce(function (newObj, curr) {
      return fn.apply(undefined, _toConsumableArray([newObj, obj[curr], curr, obj].slice(0, fn.length || 2)));
    }, initialValue);
  };
  exportFunctions.reduceObject = reduceObject;

  /**
   * Helper function for testing if the item is an Object or Array that contains properties or elements
   * @param {Object|Array} item - Object or Array to test
   * @returns {boolean}
   */
  var notEmptyObjectOrArray = function notEmptyObjectOrArray(item) {
    return !!((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && Object.keys(item).length || Array.isArray(item) && item.length);
  };
  exportFunctions.notEmptyObjectOrArray = notEmptyObjectOrArray;

  /**
   * Function is a predicate, accepts optional arguments of a property and a propertyName to be used in the test.
   * @callback recursiveMapTest
   * @param {*} [property] - The property value to be tested.
   * @param {string} [propertyName] - The current property being processed in the object.
   * @returns {boolean}
   */

  /**
   * This is typically a reference to the calling function which will be called recursively.
   * @callback recursiveMapCallback
   * @param {*} propertyReference - A reference to the current property being processed.
   * @param {*} [propertyValue] - The value of the current property being processed.
   * @param {...*} [args] - Additional arguments that may be needed for the recursive function callback.
   * @returns {*}
   */

  /**
   * A function to use with mapObject or just map which will either return the result
   * of re-running a function or return the original item.
   * Pass in the object to be used with map.
   * Pass in the conditions as a test function: True returns the object; False continues recursion.
   * Pass in the recursive function.
   * Add any other args to that function.
   * @param {Object|Array} obj -> The Object or array being processed.
   * @param {recursiveMapTest} test - The condition which either continues or terminates recursion.
   * @param {recursiveMapCallback} fn - A reference to the calling function to be recursively run.
   * @param {...*} [args] - Additional args which might be needed for recursiveMapCallback.
   * @returns {*|recursiveMapCallback}
   */
  var recursiveMap = function recursiveMap(obj, test, fn) {
    for (var _len4 = arguments.length, args = Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
      args[_key4 - 3] = arguments[_key4];
    }

    return function (prop, key) {
      return test.apply(undefined, _toConsumableArray([prop, key].slice(0, test.length))) ? prop : fn.apply(undefined, _toConsumableArray([obj[key], prop].slice(0, fn.length || 2)).concat(args));
    };
  };

  /**
   * A predicate to determin if the provided input meets the conditions.
   * @callback cloneExtraTest
   * @param {*} property - A reference to the current property being processed.
   * @param {String|number} propertyName - The value of the current property being processed.
   * @returns {boolean}
   */

  /**
   * Tests exceptions to what must be returned as reference vs cloned. Returns true for return reference vs false for return clone.
   * @param {Object|Array} obj - The Object or Array to be tested.
   * @param {cloneExtraTest} [extraTest=false] - Additional function which can be used in the test.
   * @returns {boolean}
   */
  var cloneRules = function cloneRules(obj) {
    var extraTest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return function (prop, key) {
      return !obj[key] || /^(parentItem|listenerArgs|element)$/.test(key) || (extraTest ? extraTest(prop, key) : false);
    };
  };

  /**
   * Re-add the Object Properties which cannot be cloned and must be directly copied to the new cloned object
   * WARNING: This is a recursive function.
   * @param {Object} cloned - A value-only copy of the original object
   * @param {Object} object - The original object that is being cloned
   * @returns {Object|Array}
   */
  var cloneCopy = function cloneCopy(object, cloned) {
    return notEmptyObjectOrArray(object) ? reduceObject(object, function (start, prop, key) {
      start[key] = cloned[key] && !/^(parentItem|listenerArgs|element)$/.test(key) ? cloneCopy(prop, cloned[key]) : prop;
      return start;
    }, cloned) : cloned;
  };

  /**
   * Clone objects for manipulation without data corruption, returns a copy of the provided object.
   * @param {Object} object - The original object that is being cloned
   * @returns {Object}
   */
  var cloneObject = function cloneObject(object) {
    return cloneCopy(object, JSON.parse(JSON.stringify(object, function (key, val) {
      return !/^(parentItem|listenerArgs|element)$/.test(key) ? val : undefined;
    })));
  };
  exportFunctions.cloneObject = cloneObject;

  /**
   * Merge two objects and provide clone or original on the provided function.
   * The passed function should accept a minimum of two objects to be merged.
   * If the desire is to mutate the input objects, then the function name should
   * have the word 'mutable' in the name (case-insensitive).
   * @param {function} fn
   * @param {Object} obj1
   * @param {Object} obj2
   * @returns {Object}
   */
  var mergeObjectsBase = function mergeObjectsBase(fn, obj1, obj2) {
    return notEmptyObjectOrArray(obj2) ? mapObject(obj2, recursiveMap(obj1, cloneRules(obj1), fn), /mutable/i.test(fn.name) ? obj1 : cloneObject(obj1)) : obj2;
  };

  /**
   * Perform a deep merge of objects. This will combine all objects and sub-objects,
   * objects having the same attributes will overwrite starting from the end of the argument
   * list and bubbling up to return a merged version of the first object.
   * WARNING: This is a recursive function.
   * @param {...Object} args
   * @returns {Object}
   */
  var mergeObjects = function mergeObjects() {
    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return args.length === 2 ? mergeObjectsBase(mergeObjects, args[0], args[1]) : args.length === 1 ? cloneObject(args[0]) : args.reduce(curry(mergeObjectsBase)(mergeObjects), {});
  };
  exportFunctions.mergeObjects = mergeObjects;

  /**
   * Perform a deep merge of objects. This will combine all objects and sub-objects,
   * objects having the same attributes will overwrite starting from the end of the argument
   * list and bubbling up to return the overwritten first object.
   * WARNING: This is a recursive function.
   * WARNING: This will mutate the first object passed in as input
   * @param {...Object} args
   * @returns {Object}
   */
  var mergeObjectsMutable = function mergeObjectsMutable() {
    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return args.length === 2 ? mergeObjectsBase(mergeObjectsMutable, args[0], args[1]) : args.length === 1 ? args[0] : args.reduce(curry(mergeObjectsBase)(mergeObjectsMutable), {});
  };
  exportFunctions.mergeObjectsMutable = mergeObjectsMutable;

  /**
   * Generate an array filled with a copy of the provided item or references to the provided item.
   * The length defines how long the array should be.
   * WARNING: This is a recursive function.
   * @param {boolean} useReference
   * @param {*} item
   * @param {number} length
   * @param {Array} [arr=[]]
   * @returns {Array.<*>}
   */
  var buildArrayBase = function buildArrayBase(useReference, item, length) {
    var arr = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    return --length > 0 ? buildArrayBase(useReference, useReference ? item : cloneObject(item), length, arr.concat([item])) : arr.concat([item]);
  };

  /**
   * Leverage buildArrayBase to generate an array filled with a copy of the provided item.
   * The length defines how long the array should be.
   * @function buildArray
   * @param {*} item
   * @param {number} length
   * @param {Array} [arr=[]]
   * @returns {Array.<*>}
   */
  exportFunctions.buildArray = curry(buildArrayBase)(false);

  /**
   * Leverage buildArrayBase to generate an array filled with references to the provided item.
   * The length defines how long the array should be.
   * @function buildArrayOfReferences
   * @param {*} item
   * @param {number} length
   * @param {Array} [arr=[]]
   * @returns {Array.<*>}
   */
  exportFunctions.buildArrayOfReferences = curry(buildArrayBase)(true);

  /**
   * A simple function to check if an item is in an array
   * @param {Array} arr
   * @param {*} prop
   * @returns {boolean}
   */
  var inArray = function inArray(arr, prop) {
    return arr.indexOf(prop) >= 0;
  };
  exportFunctions.inArray = inArray;

  /**
   * A simple function usable with reduce to get the max or min value
   * @param {boolean} getMax
   * @param {number} num1
   * @param {number} num2
   * @returns {number}
   */
  var getMaxOrMin = function getMaxOrMin(getMax, num1, num2) {
    return getMax && num2 > num1 || !getMax && num2 < num1 ? num2 : num1;
  };
  exportFunctions.getMaxOrMin = getMaxOrMin;

  /**
   * Helper for returning max value
   * @function getMax
   * @param {number} num1
   * @param {number} num2
   * @returns {number}
   */
  exportFunctions.getMax = curry(getMaxOrMin)(true);

  /**
   * Helper for returning min value
   * @function getMin
   * @param {number} num1
   * @param {number} num2
   * @returns {number}
   */
  exportFunctions.getMin = curry(getMaxOrMin)(false);

  /**
   * Create a single random number within provided range. And with optional offset,
   * The distance between the result numbers can be adjusted with interval.
   * @param {number} range
   * @param {number} [offset=0]
   * @param {number} [interval=1]
   * @returns {number}
   */
  exportFunctions.randomNumber = function (range) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return (Math.random() * range + offset) * interval;
  };

  /**
   * Create a single random integer within provide range. And with optional offset,
   * The distance between the result numbers can be adjusted with interval.
   * @param {number} range
   * @param {number} [offset=0]
   * @param {number} [interval=1]
   * @returns {number}
   */
  exportFunctions.randomInteger = function (range) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return (Math.floor(Math.random() * range) + offset) * interval;
  };

  /**
   * Compare two numbers and return:
   * -1 to indicate val1 is less than val2
   * 0 to indicate both values are the equal
   * 1 to indicate val1 is greater than val2
   * @param {number} val1 - The first number to compare
   * @param {number} val2 - The second number to compare
   * @returns {number}
   */
  var compare = function compare(val1, val2) {
    return val1 === val2 ? 0 : val1 > val2 ? 1 : -1;
  };
  exportFunctions.compare = compare;

  /**
   * Compare two Arrays and return the Object where the value for each property is as follows:
   * -1 to indicate val1 is less than val2
   * 0 to indicate both values are the equal
   * 1 to indicate val1 is greater than val2
   * The returned Object uses the element values as the property names
   * @param {Array} arr1 - The first array to compare
   * @param {Array} arr2 - The second array to compare
   * @param {Array} [parents=[]] - Used to track circular references
   * @returns {Object.<string, number>}
   */
  exportFunctions.compareArrays = function (arr1, arr2) {
    var parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    return arr2.filter(function (attr, key) {
      return !inArray(arr1, attr) || arr1[key] !== attr;
    }).concat(arr1).reduce(function (returnObj, attr) {
      returnObj[JSON.stringify(attr, function (key, val) {
        return !/^(parentItem|listenerArgs|element)$/.test(key) ? val : undefined;
      })] = compare(arr2.filter(function (val) {
        return val === attr;
      }).length, arr1.filter(function (val) {
        return val === attr;
      }).length);
      return returnObj;
    }, {});
  };

  /**
   * This was adapted from a blog post on Composing Software written by Eric Elliott. Trace provides a way to traces
   * steps through code via the console, while maintaining the functional-style return value.
   * Returns a function which can then receive a value to output, the value will then be returned.
   * @author Eric Elliott
   * @param {string} label - Pass an identifying label of the value being output.
   * @returns {function(*=)}
   */
  var trace = function trace(label) {
    return function (value) {
      console.info(label + ': ', value);
      return value;
    };
  };
  exportFunctions.trace = trace;

  /**
   * Run Timeout functions one after the other in queue
   * WARNING: This is a recursive function.
   * @param {function} fn
   * @param {number} time
   * @param {...*} args
   * @returns {{id: number, func: function, timeout: number, args: {Array}, result: *}}
   */
  var queueTimeout = function queueTimeout() {
    for (var _len7 = arguments.length, args = Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {
      args[_key7 - 2] = arguments[_key7];
    }

    var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    queueTimeout.queue = queueTimeout.queue || [];
    queueTimeout.isRunning = queueTimeout.isRunning || false;
    var queueItem = { id: 0, func: fn, timeout: time, args: args, result: 0 };
    if (fn) {
      queueTimeout.queue.push(queueItem);
    }

    if (queueTimeout.queue.length && !queueTimeout.isRunning) {
      queueTimeout.isRunning = true;
      var toRun = queueTimeout.queue.shift();
      toRun.id = setTimeout(function () {
        toRun.result = toRun.func.apply(toRun, _toConsumableArray(toRun.args));
        queueTimeout.isRunning = false;
        return queueTimeout(false);
      }, toRun.timeout);
      return toRun;
    }
    return queueItem;
  };
  exportFunctions.queueTimeout = queueTimeout;

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser

'use strict'
// Core DOM Objects
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Verify availability of document
   * @type {HTMLDocument|PseudoHTMLDocument}
   */
  var document = root.document;

  /**
   * If document remains undefined, attempt to retrieve it as a module
   */
  if (!Object.keys(root).length) {
    if (typeof require !== 'undefined') {
      var jDomPseudoDom = require('./pseudo-dom.js');
      root = jDomPseudoDom.generate();
      document = root.document;
    } else {
      console.error('objects-dom.js requires jDomPseudoDom');
    }
  }

  /**
   * Store reference to any pre-existing module of the same name
   * @type {jDomObjects|*}
   */
  var previousJDomObjects = root.jDomObjects || {};

  /**
   * All methods exported from this module are encapsulated within jDomObjects.
   * @typedef {Object} jDomObjects
   * @property {jDomObjects} jDomObjects
   * @property {DOMItemRoot} documentItem
   * @property {function} DOMItem
   * @property {function} documentDOMItem
   * @property {function} noConflict
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {jDomObjects}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.jDomObjects = previousJDomObjects;
      return exportFunctions;
    }
  };
  root.jDomObjects = exportFunctions;

  /**
   * Verify availability of jDomCore
   * @type {*|jDomCore}
   */
  var jDomCore = root.jDomCore;

  /**
   * If jDomCore remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCore === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCore = require('./core.js');
    } else {
      console.error('objects-dom.js requires jDomCore');
    }
  }

  /**
   * This is the standard definition of a listenerFunction to be used
   * @callback listenerFunction
   * @param {Event} e - The event object passed to the listener
   * @param {DOMItem} target - The element which triggered the event
   * @param {...*} [args] - Optional args as required by the listener
   */

  /**
   * An EventListener Object to be appended to the element within the DOMItem
   * @typedef {Object} EventListener
   * @property {string} listenerFunc - A string function name matching an existing {@link listenerFunction}.
   * @property {Object} listenerArgs - Additional args required for the listener function
   * @property {(boolean|Object)} listenerOptions - Provides support for options parameter of addEventListener, or false for default
   */

  /**
   * DOMItem defines the structure for a single element in the DOM
   * @typedef {Object} DOMItem
   * @property {string} tagName - This is any valid HTMLElement tagName
   * @property {Object.<string, string|Object>} attributes - All potential HTML element attributes can be defined here (including the defaulted style object)
   * @property {(Object|HTMLElement)} element - A reference to an existing HTML element will be stored here (default empty object)
   * @property {Object.<Event, EventListener>} eventListeners - An object holding all events to be registered for the associated element
   * @property {DOMItem} parentItem - A reference to the parent of this object
   * @property {Array.<DOMItem>} children - A reference to an array of child objects
   */

  /**
   * This is the basic Object for representing the DOM in a virtual perspective. All incoming attributes will be merged to the specified format.
   * @param {...Object} attributes - DOMItem-like object(s) to be merged as a DOMItem
   * @returns {DOMItem}
   * @constructor
   */
  var DOMItem = function DOMItem() {
    var _jDomCore;

    for (var _len8 = arguments.length, attributes = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      attributes[_key8] = arguments[_key8];
    }

    return (_jDomCore = jDomCore).mergeObjectsMutable.apply(_jDomCore, [{
      tagName: 'div',
      attributes: {
        style: {}
      },
      element: {},
      eventListeners: {},
      parentItem: {},
      children: []
    }].concat(attributes));
  };
  exportFunctions.DOMItem = DOMItem;

  /**
   * DOMItemHead defines the structure for a single element in the DOM
   * @typedef {DOMItem} DOMItemHead
   * @property {string} [tagName=head] - This is set to the string head referring to the HTML element of the same name
   * @property {Object.<string, string|Object>} attributes - All potential HTML element attributes can be defined here
   * @property {HTMLHeadElement} element - A reference to the HTML head element
   * @property {Array.<DOMItem>} children - A reference to an array of child objects
   * @augments DOMItem
   */

  /**
   * DOMItemBody defines the structure for a single element in the DOM
   * @typedef {DOMItem} DOMItemBody
   * @property {string} [tagName=body] - This is set to the string body referring to the HTML element of the same name
   * @property {Object.<string, string|Object>} attributes - All potential HTML element attributes can be defined here
   * @property {HTMLElement} element - A reference to the HTML body element
   * @property {Array.<DOMItem>} children - A reference to an array of child objects
   * @augments DOMItem
   */

  /**
   * Initiate the children of Root / DocumentItem. This is a helper for {@link documentDOMItem}.
   * @returns {Array.<DOMItemHead|DOMItemBody>}
   */
  var initChildren = function initChildren() {
    return [DOMItem({
      tagName: 'head',
      attributes: {},
      element: document.head,
      children: []
    }), DOMItem({
      tagName: 'body',
      attributes: {},
      element: document.body,
      children: []
    })];
  };

  /**
   * DOMItemRoot defines the structure for a single element in the DOM
   * @typedef {DOMItem} DOMItemRoot
   * @property {string} [tagName=html] - This is set to the string html referring to the HTML element of the same name
   * @property {Object} attributes - Empty object as attributes placeholder
   * @property {HTMLDocument} element - A reference to the entire Document
   * @property {Object.<string, listenerFunction>} EventListeners - all registered listeners stored as listener name and function pairs
   * @property {Array.<DOMItemHead|DOMItemBody>} children - Two references: for head and body
   * @property {DOMItemHead} head - A specific reference to head item
   * @property {DOMItemBody} body - A specific reference to body item
   * @augments DOMItem
   */

  /**
   * Initiate the Root for DocumentItem. This is primary a helper for {@link documentDOMItem}.
   * @param {Array.<DOMItemHead|DOMItemBody>} children - Provide an array of Head and Body (usually via {@link initChildren})
   * @param {Object.<string, listenerFunction>} listeners - An object of all event listeners to be registered in the DOM
   * @returns {DOMItemRoot}
   */
  var initRoot = function initRoot(children) {
    var listeners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return DOMItem({
      tagName: 'html',
      attributes: {},
      element: document,
      eventListeners: listeners,
      children: children,
      head: children[0],
      body: children[1]
    });
  };

  /**
   * Return a DOMItem style reference to the document. The rootItem argument is a
   * system function and not necessary to implement.
   * @param {Object.<string, listenerFunction>} listeners - An object of all event listeners to be registered in the DOM
   * @param {Object} [rootItem=DOMItemRoot] - This is a reference to DOMItemRoot which will be defaulted with {@link initRoot}
   * @returns {DOMItemRoot}
   */
  var documentDOMItem = function documentDOMItem() {
    var listeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var rootItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : initRoot(initChildren(), listeners);

    rootItem.children = rootItem.children.map(function (child) {
      return DOMItem(child, { parentItem: rootItem });
    });
    rootItem.head = rootItem.children[0];
    rootItem.body = rootItem.children[1];
    return DOMItem(rootItem);
  };
  exportFunctions.documentDOMItem = documentDOMItem;

  /**
   * Create reference for storing document changes
   * @type {DOMItem}
   */
  exportFunctions.documentItem = documentDOMItem();

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser

'use strict'
// Core DOM management functions
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Verify availability of document
   * @type {HTMLDocument|PseudoHTMLDocument}
   */
  var document = root.document;

  /**
   * If document remains undefined, attempt to retrieve it as a module
   */
  if (!Object.keys(root).length) {
    if (typeof require !== 'undefined') {
      var jDomPseudoDom = require('./pseudo-dom.js');
      root = jDomPseudoDom.generate();
      document = root.document;
    } else {
      console.error('objects-dom.js requires jDomPseudoDom');
    }
  }

  /**
   * Store reference to any pre-existing module of the same name
   * @type {jDomCoreDom|*}
   */
  var previousJDomCoreDom = root.jDomCoreDom || {};

  /**
   * All methods exported from this module are encapsulated within jDomCoreDom.
   * @typedef {Object} jDomCoreDom
   * @property {jDomCoreDom} jDomCoreDom
   * @property {function} appendAllHTML
   * @property {function} appendHTML
   * @property {function} appendListeners
   * @property {function} assignListener
   * @property {function} bindAllElements
   * @property {function} bindAllListeners
   * @property {function} bindElement
   * @property {function} bindListeners
   * @property {function} buildHTML
   * @property {function} elementChanges
   * @property {function} elementHasAttribute
   * @property {function} generateElement
   * @property {function} getChildrenByClass
   * @property {function} getChildrenByName
   * @property {function} getChildrenFromAttribute
   * @property {function} getParentsByClass
   * @property {function} getParentsByName
   * @property {function} getParentsByTagName
   * @property {function} getTopParentItem
   * @property {function} noConflict
   * @property {function} registerListener
   * @property {function} registerListeners
   * @property {function} removeChild
   * @property {function} renderHTML
   * @property {function} retrieveListener
   * @property {function} updateElement
   * @property {function} updateElements
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {jDomCoreDom}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.jDomCoreDom = previousJDomCoreDom;
      return exportFunctions;
    }
  };
  root.jDomCoreDom = exportFunctions;

  /**
   * Verify availability of jDomCore
   * @type {*|jDomCore}
   */
  var jDomCore = root.jDomCore;

  /**
   * If jDomCore remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCore === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCore = require('./core.js');
    } else {
      console.error('core-dom.js requires jDomCore');
    }
  }

  /**
   * Verify availability of jDomCore
   * @type {*|jDomObjects}
   */
  var jDomObjects = root.jDomObjects;

  /**
   * If jDomObjects remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomObjects === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomObjects = require('./objects-dom.js');
    } else {
      console.error('core-dom.js requires jDomObjects');
    }
  }

  /**
   * Check if the provided Element has the provided attributes.
   * Returns a boolean, or an array of 1 / 0 / -1 based on the comparison status.
   * @param {HTMLElement|PseudoHTMLElement} element
   * @param {string} key
   * @param {string} attr
   * @returns {boolean|Object.<string, number>}
   */
  var elementHasAttribute = function elementHasAttribute(element, key, attr) {
    // if element is not a valid element then return false
    if (!element.style) {
      return false;
    }

    // check the key is a property of the element
    // compare current to new one
    if (key in element) {
      // For attributes which are objects or multi-part strings
      // -1 = remove attribute, 0 = no change, 1 = add attribute
      if (/^(style|className)$/.test(key)) {
        return jDomCore.compareArrays(typeof attr === 'string' ? element[key].split(' ') : Object.keys(element[key]), typeof attr === 'string' ? attr.split(' ') : Object.keys(attr));
      }
      return element[key] === attr;
    }
    return element.hasAttribute(key) && element.getAttribute(key) === attr;
  };
  exportFunctions.elementHasAttribute = elementHasAttribute;

  /**
   * Given a jDomObjects.DOMItem as config, this function will return the changes to be applied
   * to the stored element property.
   * @param {Object} config
   * @returns {Object}
   */
  var elementChanges = function elementChanges(config) {
    if (config.element.tagName.toLowerCase() !== config.tagName.toLowerCase()) {
      return generateElement(config);
    }
    config.attributes = jDomCore.filterObject(config.attributes, function (attr1, key1) {
      return jDomCore.filterObject(jDomCore.mapObject(config.attributes, function (attr2, key2) {
        return (typeof attr2 === 'undefined' ? 'undefined' : _typeof(attr2)) === 'object' || key2 === 'className' ? jDomCore.filterObject(elementHasAttribute(config.element, key2, attr2), function (attr3) {
          return attr3 === 1;
        }) : !elementHasAttribute(config.element, key2, attr2);
      }), function (attr4) {
        return !!attr4;
      })[key1];
    });
    return config;
  };
  exportFunctions.elementChanges = elementChanges;

  /**
   * Update a single jDomObjects.DOMItem element with the provided attributes / style / elementProperties
   * @param config
   * @returns {*}
   */
  var updateElement = function updateElement(config) {
    if (config.element.style) {
      config.attributes = jDomCore.mapObject(elementChanges(config).attributes, function (attr, key) {
        if (key in config.element) {
          if (jDomCore.notEmptyObjectOrArray(attr)) {
            return jDomCore.mapObject(jDomCore.filterObject(attr, function (param, k) {
              return (/^\D+$/.test(k)
              );
            }), function (p, i) {
              config.element.style[i] = p;
              return p;
            }, config.element.style);
          }
          config.element[key] = attr;
          return attr;
        }
        config.element.setAttribute(key, attr);
        return attr;
      });
    }
    return config;
  };
  exportFunctions.updateElement = updateElement;

  /**
   * Generate HTML element data for each object in the matrix
   * WARNING: This is a recursive function.
   * @param config
   * @returns {*}
   */
  var updateElements = function updateElements(config) {
    config = updateElement(config);
    config.children.map(function (child) {
      return updateElements(child);
    });
    return config;
  };
  exportFunctions.updateElements = updateElements;

  /**
   * Create an HTML element based on the provided attributes and return the element as an Object.
   * @param config
   */
  var generateElement = function generateElement(config) {
    config.element = document.createElement(config.tagName);
    return updateElement(config);
  };
  exportFunctions.generateElement = generateElement;

  /**
   * Generate HTML element data for each object in the matrix
   * WARNING: This is a recursive function.
   * @param item
   * @param parent
   */
  var bindAllElements = function bindAllElements(item) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jDomObjects.documentItem;

    jDomCore.mapObject(jDomObjects.DOMItem(item), function (prop) {
      return prop;
    }, item);
    item.element = item.element && item.element.style ? item.element : bindElement(item).element;
    item.parentItem = parent.body || parent;
    item.children.map(function (child) {
      return bindAllElements(child, item);
    });
    return item;
  };
  exportFunctions.bindAllElements = bindAllElements;

  /**
   * Generate HTML element data for each object in the matrix
   * WARNING: This is a recursive function.
   * @param item
   */
  var bindElement = function bindElement(item) {
    if (!item.element || !item.element.style) {
      item.element = generateElement(item).element;
    }
    return item;
  };
  exportFunctions.bindElement = bindElement;

  /**
   * Append each HTML element data in a combined HTML element
   * WARNING: This is a recursive function.
   * @param item
   * @returns {*}
   */
  var buildHTML = function buildHTML(item) {
    item.children.map(function (i) {
      return item.element.appendChild(buildHTML(i).element);
    });
    return item;
  };
  exportFunctions.buildHTML = buildHTML;

  /**
   * Select the parent HTML element for appending new elements
   * @param item
   * @param parent
   * @returns {*}
   */
  var appendAllHTML = function appendAllHTML(item) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jDomObjects.documentItem.body;

    var parentItem = parent.body ? parent.body : parent;
    if (!jDomCore.inArray(parentItem.children, item)) {
      parentItem.children.push(item);
    }
    return buildHTML(parentItem);
  };
  exportFunctions.appendAllHTML = appendAllHTML;

  /**
   * Select the parent HTML element for appending new elements
   * @param item
   * @param parent
   * @returns {*}
   */
  var appendHTML = function appendHTML(item) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jDomObjects.documentItem.body;

    var parentItem = parent.body ? parent.body : parent;
    if (!jDomCore.inArray(parentItem.children, item)) {
      parentItem.children.push(item);
    }
    if (!item.element || !item.element.style) {
      item = bindElement(item);
    }
    parentItem.element.appendChild(item.element);
    return item;
  };
  exportFunctions.appendHTML = appendHTML;

  /**
   * Reverse of appendHTML, remove an element
   * @param item
   * @param parent
   * @returns {Array.<HTMLElement|PseudoHTMLElement>}
   */
  var removeChild = function removeChild(item) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jDomObjects.documentItem.body;

    parent.element.removeChild(item.element);
    return parent.children.splice(parent.children.indexOf(item), 1);
  };
  exportFunctions.removeChild = removeChild;

  /**
   * Register a single listener function as part of the root jDomObjects.DOMItem.
   * @param {function} listener
   * @param {string} [name]
   * @param {Object} [parent]
   * @returns {function}
   */
  var registerListener = function registerListener(listener) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : listener.name;
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : jDomObjects.documentItem;
    return Object.assign(parent.eventListeners, { name: listener });
  };
  exportFunctions.registerListener = registerListener;

  /**
   * Register multiple listeners from an array of functions.
   * @param {Array.<function>} listeners
   * @param {Object} [parent]
   * @returns {Object}
   */
  var registerListeners = function registerListeners(listeners) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jDomObjects.documentItem;
    return jDomCore.mergeObjects(parent, { eventListeners: listeners }, parent.eventListeners);
  };
  exportFunctions.registerListeners = registerListeners;

  /**
   * Based on the provided function / listener name, retrieve the associated function from the root jDomObjects.DOMItem
   * @param listenerName
   * @param parent
   * @returns {{}}
   */
  var retrieveListener = function retrieveListener(listenerName) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jDomObjects.documentItem;
    return jDomCore.inArray(Object.keys(parent.eventListeners), listenerName) ? parent.eventListeners[listenerName] : {};
  };
  exportFunctions.retrieveListener = retrieveListener;

  /**
   * Provide compatibility for using the options parameter of addEventListener
   * @param options
   * @returns {boolean}
   */
  var listenerOptions = function listenerOptions(options) {
    if (typeof listenerOptions.supportsOptions === 'undefined') {
      listenerOptions.supportsOptions = true;
      try {
        window.addEventListener('test', null, { capture: false, once: false, passive: false });
      } catch (err) {
        listenerOptions.supportsOptions = false;
      }
    }
    return (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && listenerOptions.supportsOptions ? options : false;
  };

  /**
   * Provide compatibility for assigning listeners.
   * @param trigger
   * @param elem
   * @param fn
   * @param options
   * @returns {*}
   */
  var assignListener = function assignListener(trigger, elem, fn, options) {
    elem.addEventListener ? elem.addEventListener(trigger, fn, listenerOptions(options)) : elem.attachEvent ? elem.attachEvent('on' + trigger, fn) : elem['on' + trigger] = fn;
    return fn;
  };
  exportFunctions.assignListener = assignListener;

  /**
   * When there may be extra data needed for the event listener function
   * call this function may be used as a helper to pass the additional data.
   * Also, if it is desirable to add event listeners during run-time, this
   * function can be used to achieve this.
   * WARNING: This is a recursive function.
   * @param item
   * @param event
   * @param listener
   * @param args
   * @param options
   * @returns {*}
   */
  var appendListeners = function appendListeners(item, event, listener) {
    var args = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    item.children = item.children || [];
    if (item.eventListeners && item.eventListeners[event]) {
      item.eventListeners[event] = { listenerFunc: listener, listenerArgs: args, listenerOptions: options };
    }
    item.children.map(function (i) {
      return appendListeners(i, event, listener, args, options);
    });
    return item;
  };
  exportFunctions.appendListeners = appendListeners;

  /**
   * Based on the eventListeners property of the provided item, bind the
   * listeners to the associated element property for each item in the jDomObjects.DOMItem structure.
   * WARNING: This is a recursive function.
   * @param item
   * @returns {*}
   */
  var bindAllListeners = function bindAllListeners(item) {
    if (item.eventListeners && Object.keys(item.eventListeners).length && item.element.style) {
      jDomCore.mapObject(item.eventListeners, function (attr, key) {
        return assignListener(key, item.element, function (e) {
          return attr.listenerFunc(e, item, attr.listenerArgs);
        }, attr.listenerOptions);
      });
    }
    item.children = item.children.map(function (i) {
      return bindAllListeners(i);
    });
    return item;
  };
  exportFunctions.bindAllListeners = bindAllListeners;

  /**
   * Based on the eventListeners property of the provided item, bind the
   * listeners to the associated element property for the provided jDomObjects.DOMItem.
   * @param item
   * @returns {*}
   */
  var bindListeners = function bindListeners(item) {
    if (item.eventListeners && Object.keys(item.eventListeners).length && item.element.style) {
      jDomCore.mapObject(item.eventListeners, function (attr, event) {
        return assignListener(event, item.element, function (e) {
          return attr.listenerFunc(e, item, attr.listenerArgs);
        }, attr.listenerOptions);
      });
    }
    return item;
  };
  exportFunctions.bindListeners = bindListeners;

  /**
   * A selector function for retrieving existing child jDomObjects.DOMItems from the given parent item.
   * This function will check all the children starting from item, and scan the attributes
   * property for matches. The return array contains children matching from all levels.
   * WARNING: This is a recursive function.
   * @param attr
   * @param value
   * @param item
   * @returns {Array}
   */
  var getChildrenFromAttribute = function getChildrenFromAttribute(attr, value) {
    var item = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : jDomObjects.documentItem.body;
    return item.attributes[attr] && item.attributes[attr] === value ? item.children.reduce(function (a, b) {
      return a.concat(getChildrenFromAttribute(attr, value, b));
    }, []).concat([item]) : item.children.reduce(function (a, b) {
      return a.concat(getChildrenFromAttribute(attr, value, b));
    }, []);
  };
  exportFunctions.getChildrenFromAttribute = getChildrenFromAttribute;

  /**
   * Helper for getting all jDomObjects.DOMItems starting at parent and having specified className attribute
   */
  var getChildrenByClass = jDomCore.curry(getChildrenFromAttribute)('className');
  exportFunctions.getChildrenByClass = getChildrenByClass;

  /**
   * Helper for getting all jDomObjects.DOMItems starting at parent and having specified name attribute
   */
  var getChildrenByName = jDomCore.curry(getChildrenFromAttribute)('name');
  exportFunctions.getChildrenByName = getChildrenByName;

  /**
   * A selector function for retrieving existing child jDomObjects.DOMItems from the given parent item.
   * This function will check all the children starting from item, and scan the attributes
   * property for matches. The return array contains children matching from all levels.
   * WARNING: This is a recursive function.
   * @param attr
   * @param value
   * @param item
   * @returns {Array}
   */
  var getParentsFromAttribute = function getParentsFromAttribute(attr, value) {
    var item = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : jDomObjects.documentItem.body;
    return !Object.keys(item.parentItem).length ? [] : (item.attributes[attr] || item[attr] || false) === value ? getParentsFromAttribute(attr, value, item.parentItem).concat([item]) : getParentsFromAttribute(attr, value, item.parentItem);
  };

  /**
   * Helper for getting all jDomObjects.DOMItems starting at child and having specified className attribute
   */
  var getParentsByClass = jDomCore.curry(getParentsFromAttribute)('className');
  exportFunctions.getParentsByClass = getParentsByClass;

  /**
   * Helper for getting all jDomObjects.DOMItems starting at child and having specified name attribute
   */
  var getParentsByName = jDomCore.curry(getParentsFromAttribute)('name');
  exportFunctions.getParentsByName = getParentsByName;

  /**
   * Helper for getting all jDomObjects.DOMItems starting at child and having specified tagName
   */
  var getParentsByTagName = jDomCore.curry(getParentsFromAttribute)('tagName');
  exportFunctions.getParentsByTagName = getParentsByTagName;

  /**
   * Get the upper parentItem for the provided child. (usually this is a jDomObjects.documentItem reference)
   * WARNING: This is a recursive function.
   * @param item
   */
  var getTopParentItem = function getTopParentItem(item) {
    return Object.keys(item.parentItem).length ? getTopParentItem(item.parentItem) : item;
  };
  exportFunctions.getTopParentItem = getTopParentItem;

  /**
   * This is a shortcut for building the specified HTML elements and appending them to the DOM
   * with associated listeners.
   * The final argument is specific for adding event listeners with options.
   * @param item
   * @param parent
   * @returns {*}
   */
  var renderHTML = function renderHTML(item) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jDomObjects.documentItem;

    jDomCore.mapObject(jDomObjects.DOMItem(item), function (prop) {
      return prop;
    }, item);
    item.element = item.element && item.element.style ? item.element : bindElement(item).element;
    item.eventListeners = jDomCore.mapObject(item.eventListeners, function (prop) {
      return jDomCore.mergeObjects(prop, { listenerFunc: retrieveListener(prop.listenerFunc, getTopParentItem(parent)) });
    });
    item.parentItem = parent.body || parent;
    item = bindListeners(appendHTML(item, parent));
    item.children.map(function (child) {
      return renderHTML(child, item);
    });
    return item;
  };
  exportFunctions.renderHTML = renderHTML;

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser

'use strict'
// Core Matrix Objects
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Store reference to any pre-existing module of the same name
   * @type {jDomObjectsMatrix|*}
   */
  var previousJDomObjectsMatrix = root.jDomObjectsMatrix || {};

  /**
   * All methods exported from this module are encapsulated within jDomObjectsMatrix.
   * @typedef {Object} jDomObjectsMatrix
   * @property {jDomObjectsMatrix} jDomObjectsMatrix
   * @property {function} cube
   * @property {function} matrix
   * @property {function} noConflict
   * @property {function} point
   * @property {function} square
   * @property {function} tile
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {jDomObjectsMatrix}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.jDomObjectsMatrix = previousJDomObjectsMatrix;
      return exportFunctions;
    }
  };
  root.jDomObjectsMatrix = exportFunctions;

  /**
   * Verify availability of jDomCore
   * @type {*|jDomCore}
   */
  var jDomCore = root.jDomCore;

  /**
   * If jDomCore remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCore === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCore = require('./core.js');
    } else {
      console.error('objects-dom.js requires jDomCore');
    }
  }

  /**
   * Verify availability of jDomObjects
   * @type {*|jDomObjects}
   */
  var jDomObjects = root.jDomObjects;

  /**
   * If jDomObjects remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomObjects === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomObjects = require('./objects-dom.js');
    } else {
      console.error('core-dom.js requires jDomObjects');
    }
  }

  /**
   * A string representing an axis: x, y, z
   * @typedef {string} axis
   */

  /**
   * A number representing a coordinate in a {@link Matrix}
   * @typedef {number} coordinate
   */

  /**
   * Point stores a location in a {@link Matrix} defined by three key-value pairs ({@link axis}=>{@link coordinate})
   * @typedef {Object.<axis, coordinate>} Point
   * @property {coordinate} x - The X-coordinate of a Point
   * @property {coordinate} y - The Y-coordinate of a Point
   * @property {coordinate} z - The Z-coordinate of a Point
   */

  /**
   * Store the point data for an x, y, z {@link Matrix}.
   * @param {coordinate} x - The numeric value for X-coordinate
   * @param {coordinate} y - The numeric value for Y-coordinate
   * @param {coordinate} [z=0] - The numeric value for Z-coordinate (default to 0 for 2D {@link Matrix})
   * @returns {Point}
   */
  var point = function point(x, y) {
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return {
      x: x,
      y: y,
      z: z
    };
  };
  exportFunctions.point = point;

  /**
   * MatrixTile is an Object which stores a reference a {@link Point} and can be populated with additionally associated fields.
   * @typedef {Object.<string, Point>} MatrixTile
   * @property {Point} point - a reference to its location in a {@link Matrix}
   */

  /**
   * A default tile in the {@link Matrix}
   * @returns {MatrixTile}
   */
  var tile = function tile() {
    return {
      point: {}
    };
  };
  exportFunctions.tile = tile;

  /**
   * Matrix is a multi-level {@link DOMItem} which is used to visually represent a mathematical grid / matrix.
   * The matrix consists of four DOMItem levels, at the top tier is the Matrix container with class matrix.
   * The second tier represents the z axis (with property axis='z') and has the class layer.
   * The third tier represents the y axis (with property axis='y') and has the class row.
   * The fourth (final) tier represents the x axis (with property axis='x') and has the class column.
   * The {@link MatrixTile} is attached on the x axis tier.
   * The number of children at each level is defined by the size of the matrix, the end result is a multidimensional array.
   * @typedef {DOMItem} Matrix
   * @augments DOMItem
   */

  /**
   * Create a 3d matrix of i with x by y by z size,
   * add additional objects for each layer as well
   * @param {MatrixTile} i - All the data to be presented as part of the specified point, requires MatrixTile base
   * @param {coordinate} x - A number / coordinate defining the width of the matrix.
   * @param {coordinate} y - A number / coordinate defining the height of the matrix.
   * @param {coordinate} [z=1] - A number / coordinate defining the depth of the matrix.
   * @param {...Object} [props] - Additional data may be merged into every level of the matrix.
   * @returns {Matrix}
   */
  var matrix = function matrix(i, x, y) {
    for (var _len9 = arguments.length, props = Array(_len9 > 4 ? _len9 - 4 : 0), _key9 = 4; _key9 < _len9; _key9++) {
      props[_key9 - 4] = arguments[_key9];
    }

    var _jDomObjects, _jDomObjects2, _jDomObjects3;

    var z = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    return jDomObjects.DOMItem({
      tagName: 'div',
      attributes: {
        className: 'matrix'
      },
      children: jDomCore.buildArray((_jDomObjects = jDomObjects).DOMItem.apply(_jDomObjects, [{
        axis: 'z',
        tagName: 'div',
        attributes: {
          className: 'layer'
        },
        children: jDomCore.buildArray((_jDomObjects2 = jDomObjects).DOMItem.apply(_jDomObjects2, [{
          axis: 'y',
          tagName: 'div',
          attributes: {
            className: 'row'
          },
          children: jDomCore.buildArray((_jDomObjects3 = jDomObjects).DOMItem.apply(_jDomObjects3, [{
            axis: 'x',
            tagName: 'div',
            attributes: {
              className: 'column'
            }
          }].concat(props, [i])), x)
        }].concat(props)), y)
      }].concat(props)), z)
    });
  };
  exportFunctions.matrix = matrix;

  /**
   * Return a single layer matrix where x and y are equal
   * @param {MatrixTile} i - All the data to be presented as part of the specified point, requires MatrixTile base
   * @param {number} size - Used to define height and width as equal values (depth is set to 1)
   * @returns {Matrix}
   */
  var square = function square(i, size) {
    return matrix(i, size, size);
  };
  exportFunctions.square = square;

  /**
   * Return a matrix where x, y, and z are equal
   * @param {MatrixTile} i - All the data to be presented as part of the specified point, requires MatrixTile base
   * @param {number} size - Used to define height, width, and depth as equal values
   * @returns {Matrix}
   */
  var cube = function cube(i, size) {
    return matrix(i, size, size, size);
  };
  exportFunctions.cube = cube;

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser

'use strict'
// Core matrix functions for working with a grid of points
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Store reference to any pre-existing module of the same name
   * @type {jDomCoreMatrix|*}
   */
  var previousJDomCoreMatrix = root.jDomCoreMatrix || {};

  /**
   * All methods exported from this module are encapsulated within jDomCoreMatrix.
   * @typedef {Object} jDomCoreMatrix
   * @property {jDomCoreMatrix} jDomCoreMatrix
   * @property {function} adjacentEdgePoints
   * @property {function} adjacentPoints
   * @property {function} bindPointData
   * @property {function} checkEqualPoints
   * @property {function} checkInBetween
   * @property {function} checkValidPoint
   * @property {function} getAllPoints
   * @property {function} getAxisLengths
   * @property {function} getAxisOfCoord
   * @property {function} getDOMItemFromPoint
   * @property {function} getHighAbsoluteCoord
   * @property {function} getHighAbsoluteCoordAxis
   * @property {function} getInBetween
   * @property {function} getPointsLine
   * @property {function} getPointsLines
   * @property {function} lineEndPoint
   * @property {function} nextCell
   * @property {function} noConflict
   * @property {function} pointDifference
   * @property {function} pointDirection
   * @property {function} pointHasNegative
   * @property {function} randDirection
   * @property {function} randomStart
   * @property {function} testPointsBetween
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {jDomCoreMatrix}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.jDomCoreMatrix = previousJDomCoreMatrix;
      return exportFunctions;
    }
  };
  root.jDomCoreMatrix = exportFunctions;

  /**
   * Verify availability of jDomObjectsMatrix
   * @type {*|jDomCore}
   */
  var jDomCore = root.jDomCore;

  /**
   * If jDomCore remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCore === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCore = require('./core.js');
    } else {
      console.error('core-matrix.js requires jDomCore');
    }
  }

  /**
   * Verify availability of jDomObjectsMatrix
   * @type {*|jDomObjectsMatrix}
   */
  var jDomObjectsMatrix = root.jDomObjectsMatrix;

  /**
   * If jDomCoreDom remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomObjectsMatrix === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomObjectsMatrix = require('./objects-matrix.js');
    } else {
      console.error('core-matrix.js requires jDomObjectsMatrix');
    }
  }

  /**
   * Generate point data for each item in the matrix
   * WARNING: This is a recursive function.
   * @param item
   * @param pnt
   * @returns {*}
   */
  var bindPointData = function bindPointData(item) {
    var pnt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jDomObjectsMatrix.point(0, 0, 0);
    return jDomCore.mergeObjects(item, item.point ? { point: jDomCore.cloneObject(pnt) } : { children: item.children.map(function (el, i) {
        return bindPointData(el, jDomCore.mergeObjects(pnt, _defineProperty({}, el.axis, i)));
      }) });
  };
  exportFunctions.bindPointData = bindPointData;

  /**
   * Based on provided point and point direction generate next point.
   * @param pnt
   * @param dir
   * @returns {Object.<string, number>}
   */
  var nextCell = function nextCell(pnt, dir) {
    return jDomObjectsMatrix.point(pnt.x + dir.x, pnt.y + dir.y, pnt.z + dir.z);
  };
  exportFunctions.nextCell = nextCell;

  /**
   * Based on provided point and point direction generate next point.
   * @param start
   * @param end
   * @returns {Object.<string, number>}
   */
  var pointDifference = function pointDifference(start, end) {
    return jDomObjectsMatrix.point(end.x - start.x, end.y - start.y, end.z - start.z);
  };
  exportFunctions.pointDifference = pointDifference;

  /**
   * Given two points, compare the x, y, and z of each to see if they are the same
   * @param p1
   * @param p2
   * @returns {boolean}
   */
  var checkEqualPoints = function checkEqualPoints(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y && p1.z === p2.z;
  };
  exportFunctions.checkEqualPoints = checkEqualPoints;

  /**
   * Check if there is a negative coordinate value within the point provided
   * @param pnt
   * @returns {boolean}
   */
  var pointHasNegative = function pointHasNegative(pnt) {
    return !!Object.keys(jDomCore.filterObject(pnt, function (attr) {
      return attr < 0;
    })).length;
  };
  exportFunctions.pointHasNegative = pointHasNegative;

  /**
   * Return the first coordinate number with the highest absolute value.
   * @param pnt
   * @returns {Array.<T>|*}
   */
  var getHighAbsoluteCoord = function getHighAbsoluteCoord(pnt) {
    return jDomCore.reduceObject(pnt, jDomCore.curry(jDomCore.getMaxOrMin)(!pointHasNegative(pnt)), 0);
  };
  exportFunctions.getHighAbsoluteCoord = getHighAbsoluteCoord;

  /**
   * Having provided a coordinate number, find all corresponding axis.
   * @param pnt
   * @param coord
   * @returns {*}
   */
  var getAxisOfCoord = function getAxisOfCoord(pnt, coord) {
    return Object.keys(pnt).filter(function (key) {
      return pnt[key] === coord;
    });
  };
  exportFunctions.getAxisOfCoord = getAxisOfCoord;

  /**
   * Find all axis of the highest absolute value coordinate
   * @param pnt
   * @returns {*}
   */
  var getHighAbsoluteCoordAxis = function getHighAbsoluteCoordAxis(pnt) {
    return getAxisOfCoord(pnt, getHighAbsoluteCoord(pnt));
  };
  exportFunctions.getHighAbsoluteCoordAxis = getHighAbsoluteCoordAxis;

  /**
   * Retrieve a directional coordinate value based on two provided points
   * (directions consist of two zero points and a single point of 1 / -1)
   * @param start
   * @param end
   * @returns {*}
   */
  var pointDirection = function pointDirection(start, end) {
    return jDomCore.mergeObjects(jDomObjectsMatrix.point(0, 0, 0), _defineProperty({}, '' + getHighAbsoluteCoordAxis(pointDifference(start, end))[0], pointHasNegative(pointDifference(start, end)) ? -1 : 1));
  };
  exportFunctions.pointDirection = pointDirection;

  /**
   * Generate a random starting point for a line with the provided length and direction.
   * @param length
   * @param dir
   * @param lengthLimits
   * @returns {{x: number, y: number, z: number}}
   */
  var randomStart = function randomStart(length, dir) {
    var lengthLimits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : jDomObjectsMatrix.point(10, 10, 10);
    return jDomObjectsMatrix.point(jDomCore.randomInteger(lengthLimits.x - (length - 1) * dir.x), jDomCore.randomInteger(lengthLimits.y - (length - 1) * dir.y), jDomCore.randomInteger(lengthLimits.z - (length - 1) * dir.z));
  };
  exportFunctions.randomStart = randomStart;

  /**
   * Given a start point, line length, and a direction, generate the end point of the line.
   * @param start
   * @param length
   * @param dir
   * @returns {Object.<string, number>}
   */
  var lineEndPoint = function lineEndPoint(start, length, dir) {
    return jDomObjectsMatrix.point(start.x + dir.x * (length - 1), start.y + dir.y * (length - 1), start.z + dir.z * (length - 1));
  };
  exportFunctions.lineEndPoint = lineEndPoint;

  /**
   * Having provided two points, return an array of transition points
   * connecting 'start' and 'end'. return array includes 'start' (line[0])
   * and 'end' (line[line.length-1])
   * @param start
   * @param end
   * @param line
   * @returns {Array.<*>}
   */
  var getPointsLine = function getPointsLine(start, end) {
    var line = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    return checkEqualPoints(start, end) ? line.concat([start]) : getPointsLine(nextCell(start, pointDirection(start, end)), end, line.concat([start]));
  };
  exportFunctions.getPointsLine = getPointsLine;

  /**
   * Takes an array of arrays containing two points each. Calls getPointsLine for each array of points.
   * Returns an array of all points captured for each line segment
   * @param lines
   * @returns {Array.<*>}
   */
  var getPointsLines = function getPointsLines(lines) {
    return lines.reduce(function (first, next) {
      return first.concat(getPointsLine.apply(undefined, _toConsumableArray(next)));
    }, []);
  };
  exportFunctions.getPointsLines = getPointsLines;

  /**
   * Given a start and end point, test the points between with the provided function.
   * Return the points as part of true or/and false properties based on the test.
   * @param start
   * @param end
   * @param matrix
   * @param func
   * @param inclusive
   * @returns {{true: Array, false: Array}}
   */
  var testPointsBetween = function testPointsBetween(start, end, matrix, func) {
    var inclusive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    return getPointsLine(start, end).filter(function (prop, i, line) {
      return i !== 0 && i !== line.length - 1 || inclusive;
    }).reduce(function (newPoints, next) {
      return jDomCore.mergeObjects(newPoints, _defineProperty({}, '' + !!func(next, matrix), [next]));
    }, {
      true: [],
      false: []
    });
  };
  exportFunctions.testPointsBetween = testPointsBetween;

  /**
   * Retrieve all points between start and end as either true or
   * false properties based on the function used.
   * @param start
   * @param end
   * @param matrix
   * @param func
   * @param inclusive
   * @returns {{true: Array, false: Array}}
   */
  var getInBetween = function getInBetween(start, end, matrix, func) {
    var inclusive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    return jDomCore.mergeObjects({
      true: [],
      false: []
    }, testPointsBetween(start, end, matrix, func, inclusive));
  };
  exportFunctions.getInBetween = getInBetween;

  /**
   * Given two points, check the cells between using specified function.
   * When inclusive is set to true the provided start and end points will also be tested
   * @param start
   * @param end
   * @param matrix
   * @param func
   * @param inclusive
   * @returns {boolean}
   */
  var checkInBetween = function checkInBetween(start, end, matrix, func) {
    var inclusive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    return inclusive && (func(start, matrix) || func(end, matrix)) ? true : !!testPointsBetween(start, end, matrix, func).true.length;
  };
  exportFunctions.checkInBetween = checkInBetween;

  /**
   * Return point-like object with all of the axis lengths.
   * @param matrix
   */
  var getAxisLengths = function getAxisLengths(matrix) {
    return jDomObjectsMatrix.point(matrix.children[0].children[0].children.length, matrix.children[0].children.length, matrix.children.length);
  };
  exportFunctions.getAxisLengths = getAxisLengths;

  /**
   * Get random direction point
   * @param useCoords
   */
  var randDirection = function randDirection() {
    var useCoords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return useCoords.length ? useCoords[jDomCore.randomInteger(useCoords.length)] : jDomObjectsMatrix.point(0, 0, 0);
  };
  exportFunctions.randDirection = randDirection;

  /**
   * Test if the provided point exists in the matrix.
   * @param pnt
   * @param matrix
   */
  var checkValidPoint = function checkValidPoint(pnt, matrix) {
    return !!matrix.children[pnt.z] && !!matrix.children[pnt.z].children[pnt.y] && !!matrix.children[pnt.z].children[pnt.y].children[pnt.x] && !!matrix.children[pnt.z].children[pnt.y].children[pnt.x].point;
  };
  exportFunctions.checkValidPoint = checkValidPoint;

  /**
   * Test if the provided point exists in the matrix.
   * @param pnt
   * @param matrix
   */
  var getDOMItemFromPoint = function getDOMItemFromPoint(pnt, matrix) {
    return checkValidPoint(pnt, matrix) ? matrix.children[pnt.z].children[pnt.y].children[pnt.x] : false;
  };
  exportFunctions.getDOMItemFromPoint = getDOMItemFromPoint;

  /**
   * Return an array of all the points in the matrix
   * @param matrix
   * @param allPoints
   * @returns {Array}
   */
  var getAllPoints = function getAllPoints(matrix) {
    var allPoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return matrix.point ? allPoints.concat([matrix.point]) : matrix.children.reduce(function (allPoints, child) {
      return allPoints.concat(getAllPoints(child, []));
    }, []);
  };
  exportFunctions.getAllPoints = getAllPoints;

  /**
   * Return all valid points surrounding a provided point
   * @param pnt
   * @param matrix
   * @returns {Array}
   */
  var adjacentPoints = function adjacentPoints(pnt, matrix) {
    return getPointsLines([[jDomObjectsMatrix.point(-1, 1, 1), jDomObjectsMatrix.point(1, -1, -1)], [jDomObjectsMatrix.point(1, 1, 1), jDomObjectsMatrix.point(-1, 1, -1)], [jDomObjectsMatrix.point(-1, -1, 1), jDomObjectsMatrix.point(1, -1, 1)], [jDomObjectsMatrix.point(1, 0, 0), jDomObjectsMatrix.point(1, 1, -1)], [jDomObjectsMatrix.point(-1, 1, 0), jDomObjectsMatrix.point(1, 1, 0)]]).concat([jDomObjectsMatrix.point(0, 0, 1), jDomObjectsMatrix.point(1, 0, 0), jDomObjectsMatrix.point(-1, 0, -1), jDomObjectsMatrix.point(0, 0, -1)]).map(function (p) {
      return nextCell(pnt, p);
    }).filter(function (p) {
      return checkValidPoint(nextCell(pnt, p), matrix);
    });
  };
  exportFunctions.adjacentPoints = adjacentPoints;

  /**
   * Return all points which touch on edges (not diagonal)
   * @param pnt
   * @param matrix
   */
  var adjacentEdgePoints = function adjacentEdgePoints(pnt, matrix) {
    return [jDomObjectsMatrix.point(-1, 0, 0), jDomObjectsMatrix.point(1, 0, 0), jDomObjectsMatrix.point(0, -1, 0), jDomObjectsMatrix.point(0, 1, 0), jDomObjectsMatrix.point(0, 0, -1), jDomObjectsMatrix.point(0, 0, 1)].map(function (p) {
      return nextCell(pnt, p);
    }).filter(function (p) {
      return checkValidPoint(p, matrix);
    });
  };
  exportFunctions.adjacentEdgePoints = adjacentEdgePoints;

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser

'use strict'
// Custom layout objects leveraging the DOMItem object
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Store reference to any pre-existing module of the same name
   * @type {jDomLayout|*}
   */
  var previousJDomLayout = root.jDomLayout || {};

  /**
   * All methods exported from this module are encapsulated within jDomLayout.
   * @typedef {Object} jDomLayout
   * @property {jDomLayout} jDomLayout
   * @property {function} boards
   * @property {function} finalScore
   * @property {function} mainMenu
   * @property {function} noConflict
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {jDomLayout}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.jDomLayout = previousJDomLayout;
      return exportFunctions;
    }
  };
  root.jDomLayout = exportFunctions;

  /**
   * This will be the main menu for the game.
   * @param {Object} parent
   * @returns {DOMIem}
   */
  var mainMenu = function mainMenu() {
    var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return {
      tagName: 'div',
      attributes: {
        className: 'main-menu'
      },
      children: [{
        tagName: 'div',
        attributes: {
          className: 'content'
        },
        children: [{
          tagName: 'form',
          attributes: {
            name: 'mainMenuForm',
            className: 'main-menu-form'
          },
          eventListeners: {
            submit: {
              listenerFunc: 'beginRound',
              listenerArgs: {},
              listenerOptions: false
            }
          },
          children: [{
            tagName: 'div',
            attributes: {
              className: 'form-group'
            },
            children: [{
              tagName: 'label',
              attributes: {
                for: 'human-players',
                innerText: 'Humans'
              }
            }, {
              tagName: 'input',
              attributes: {
                id: 'human-players',
                name: 'human-players',
                type: 'number',
                value: 0,
                min: 0,
                max: 100,
                required: ''
              }
            }]
          }, {
            tagName: 'div',
            attributes: {
              className: 'form-group'
            },
            children: [{
              tagName: 'label',
              attributes: {
                for: 'robot-players',
                innerText: 'Robots'
              }
            }, {
              tagName: 'input',
              attributes: {
                id: 'robot-players',
                name: 'robot-players',
                type: 'number',
                value: 0,
                min: 0,
                max: 100,
                required: ''
              }
            }]
          }, {
            tagName: 'label',
            attributes: {
              for: 'first-go-first',
              innerText: 'First Player Starts'
            }
          }, {
            tagName: 'input',
            attributes: {
              id: 'first-go-first',
              name: 'first-go-first',
              type: 'checkbox'
            }
          }, {
            tagName: 'input',
            attributes: {
              type: 'submit',
              value: 'Start'
            }
          }]
        }]
      }]
    };
  };
  exportFunctions.mainMenu = mainMenu;

  /**
   * Wrapper div for player data / boards
   * @param {Array} [players=[]]
   * @returns {DOMIem}
   */
  var boards = function boards() {
    var players = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return {
      tagName: 'div',
      attributes: {
        className: 'boards'
      },
      children: players
    };
  };
  exportFunctions.boards = boards;

  /**
   * Display the final scores after a game has ended and have a button to restart.
   * @param {Array} players
   * @param {Object} [parent={}]
   * @returns {DOMIem}
   */
  var finalScore = function finalScore(players) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return {
      tagName: 'div',
      attributes: {
        className: 'final-scores'
      },
      children: [{
        tagName: 'div',
        attributes: {
          className: 'score-cards'
        },
        children: players.map(function (player) {
          return {
            tagName: 'div',
            attributes: {
              className: 'score-card',
              innerHTML: '<strong>' + player.name + '</strong><hr><br></strong><strong>Status:</strong> ' + Math.round(player.status * 100) / 100 + '%, <strong>Sunk:</strong> ' + player.attacks.sunk + '<br><strong>Hit:</strong> ' + player.attacks.hit + ' / <strong>Miss:</strong> ' + player.attacks.miss + '<br><strong>Turns:</strong> ' + player.turnCnt
            }
          };
        })
      }, {
        tagName: 'input',
        attributes: {
          type: 'button',
          value: 'Restart'
        },
        eventListeners: {
          click: { listenerFunc: 'restart', listenerArgs: {}, listenerOptions: false }
        }
      }]
    };
  };
  exportFunctions.finalScore = finalScore;

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser

'use strict'
// Game specific objects
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Store reference to any pre-existing module of the same name
   * @type {gamePieces|*}
   */
  var previousGamePieces = root.gamePieces || {};

  /**
   * All methods exported from this module are encapsulated within gamePieces.
   * @typedef {Object} gamePieces
   * @property {gamePieces} gamePieces
   * @property {function} hitTile
   * @property {function} noConflict
   * @property {function} playerSet
   * @property {function} playerStats
   * @property {function} ship
   * @property {function} shipTile
   * @property {function} waterTile
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {gamePieces}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.gamePieces = previousGamePieces;
      return exportFunctions;
    }
  };
  root.gamePieces = exportFunctions;

  /**
   * Verify availability of jDomCore
   * @type {*|jDomCore}
   */
  var jDomCore = root.jDomCore;

  /**
   * If gameUtils remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCore === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCore = require('./core.js');
    } else {
      console.error('game-pieces.js requires jDomCore');
    }
  }

  /**
   * Verify availability of jDomObjectsMatrix
   * @type {*|jDomObjectsMatrix}
   */
  var jDomObjectsMatrix = root.jDomObjectsMatrix;

  /**
   * If jDomObjectsMatrix remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomObjectsMatrix === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomObjectsMatrix = require('./objects-matrix.js');
    } else {
      console.error('game-pieces.js requires jDomObjectsMatrix');
    }
  }

  /**
   * Default properties for a tile in the battleship game.
   * @param {Object} [player={}]
   * @param {Array} [players=[]]
   * @returns {{hasShip: boolean, isHit: boolean, eventListeners: {click: {listenerFunc: attackListener, listenerArgs: {}, listenerOptions: boolean}}}}
   */
  var gameTile = function gameTile() {
    var player = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var players = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return {
      hasShip: false,
      isHit: false,
      eventListeners: {
        click: { listenerFunc: 'attackListener', listenerArgs: {}, listenerOptions: false }
      }
    };
  };

  /**
   * Set the style for tiles representing water.
   * @param {Object} [player={}]
   * @param {Array} [players=[]]
   * @returns {{hasShip: boolean, isHit: boolean, eventListeners: {click: {listenerFunc: attackListener, listenerArgs: {}, listenerOptions: boolean}}, point: {}}}
   */
  var waterTile = function waterTile() {
    var player = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var players = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return jDomCore.mergeObjects(gameTile(player, players), jDomObjectsMatrix.tile());
  };
  exportFunctions.waterTile = waterTile;

  /**
   * Set status and custom properties for tiles that have a ship
   * @returns {{hasShip: boolean}}
   */
  var shipTile = function shipTile() {
    return {
      hasShip: true
    };
  };
  exportFunctions.shipTile = shipTile;

  /**
   * Store properties of a ship which includes an array of all associated ship tiles.
   * @param {string} name
   * @returns {{name: string, status: number, parts: Array}}
   */
  var ship = function ship() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return {
      name: name,
      status: 100,
      parts: []
    };
  };
  exportFunctions.ship = ship;

  /**
   * Set the status of the tile to hit.
   * @returns {{isHit: boolean}}
   */
  var hitTile = function hitTile() {
    return {
      isHit: true
    };
  };
  exportFunctions.hitTile = hitTile;

  /**
   * Store the player attributes.
   * @param {Object} board
   * @param {string} name
   * @returns {{name: string, isRobot: boolean, status: number, turnCnt: number, attacker: boolean, attacks: {hit: number, miss: number, sunk: number}, board: {}, shipFleet: Array, playerStats: {}, tagName: string, attributes: {className: string}, children: [Object]}}
   */
  var playerSet = function playerSet() {
    var board = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return {
      name: name,
      isRobot: false,
      status: 100,
      turnCnt: 0,
      attacker: false,
      attacks: { hit: 0, miss: 0, sunk: 0 },
      board: board,
      shipFleet: [],
      playerStats: {},
      tagName: 'div',
      attributes: {
        className: 'player'
      },
      children: [board]
    };
  };
  exportFunctions.playerSet = playerSet;

  /**
   * The defined attributes for each player
   * @param {Object} [player={}]
   * @param {Object} [status=]
   * @returns {{tagName: string, attributes: {}, children: [{tagName: string, attributes: {innerHTML: string}},{tagName: string, attributes: {}, children: Array}]}}
   */
  var playerStats = function playerStats() {
    var player = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return {
      tagName: 'div',
      attributes: {},
      children: [{
        tagName: 'span',
        attributes: {
          innerHTML: '<strong>' + player.name + '</strong>: ' + status
        }
      }, {
        tagName: 'ul',
        attributes: {},
        children: player.shipFleet.map(function (ship) {
          return {
            tagName: 'li',
            attributes: {
              innerHTML: '<strong>' + ship.name + ' (' + ship.parts.length + '):</strong> ' + Math.round(ship.status * 100) / 100 + '%'
            }
          };
        })
      }]
    };
  };
  exportFunctions.playerStats = playerStats;

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser
'use strict'
// Game specific functions
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Store reference to any pre-existing module of the same name
   * @type {gameUtils|*}
   */
  var previousGameUtils = root.gameUtils || {};

  /**
   * All methods exported from this module are encapsulated within gameUtils.
   * @typedef {Object} gameUtils
   * @property {gameUtils} gameUtils
   * @property {function} checkIfHitCell
   * @property {function} checkIfShipCell
   * @property {function} filterAdjacentPoints
   * @property {function} getALowStatusItem
   * @property {function} getAdjEdgeNonHitCells
   * @property {function} getAllNonHitCells
   * @property {function} getBrokenItems
   * @property {function} getBrokenShipsPlayers
   * @property {function} getLowStatusItems
   * @property {function} noConflict
   * @property {function} numDamangedParts
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {gameUtils}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.gameUtils = previousGameUtils;
      return exportFunctions;
    }
  };
  root.gameUtils = exportFunctions;

  /**
   * Verify availability of jDomCoreMatrix
   * @type {*|jDomCoreMatrix}
   */
  var jDomCoreMatrix = root.jDomCoreMatrix;

  /**
   * If jDomCoreMatrix remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCoreMatrix === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCoreMatrix = require('./core-matrix.js');
    } else {
      console.error('functions.js requires jDomCoreMatrix');
    }
  }

  /**
   * Return the hasShip tile boolean at the specified point.
   * @param pnt
   * @param matrix
   * @returns {boolean}
   */
  var checkIfShipCell = function checkIfShipCell(pnt, matrix) {
    return matrix.children[pnt.z].children[pnt.y].children[pnt.x].hasShip;
  };
  exportFunctions.checkIfShipCell = checkIfShipCell;

  /**
   * Return the isHit tile boolean at the specified point.
   * @param pnt
   * @param matrix
   * @returns {boolean}
   */
  var checkIfHitCell = function checkIfHitCell(pnt, matrix) {
    return matrix.children[pnt.z].children[pnt.y].children[pnt.x].isHit;
  };
  exportFunctions.checkIfHitCell = checkIfHitCell;

  /**
   * Get all points which were not yet hit in the matrix.
   * @param matrix
   * @returns {Array}
   */
  var getAllNonHitCells = function getAllNonHitCells(matrix) {
    return jDomCoreMatrix.getAllPoints(matrix).filter(function (p) {
      return !checkIfHitCell(p, matrix);
    });
  };
  exportFunctions.getAllNonHitCells = getAllNonHitCells;

  /**
   * Get the points which have same edges with the provided point and are not hit.
   * @param pnt
   * @param matrix
   * @returns {Array}
   */
  var getAdjEdgeNonHitCells = function getAdjEdgeNonHitCells(pnt, matrix) {
    return jDomCoreMatrix.adjacentEdgePoints(pnt, matrix).filter(function (p) {
      return !checkIfHitCell(p, matrix);
    });
  };
  exportFunctions.getAdjEdgeNonHitCells = getAdjEdgeNonHitCells;

  /**
   * Given an array of items, return the item with the lowest status property (at the end of the array)
   * @param items
   * @returns {Array}
   */
  var getALowStatusItem = function getALowStatusItem(items) {
    return items.reduce(function (a, b) {
      return b.status <= a.status ? b : a;
    });
  };
  exportFunctions.getALowStatusItem = getALowStatusItem;

  /**
   * Given an array of items, return all items which have the lowest status property
   * @param items
   * @returns {Array}
   */
  var getLowStatusItems = function getLowStatusItems(items) {
    return items.filter(function (i) {
      return i.status <= getALowStatusItem(items).status;
    });
  };
  exportFunctions.getLowStatusItems = getLowStatusItems;

  /**
   * Given an array of items, return all of the items which have a status less than 100, but more than 0
   * @param items
   * @returns {Array}
   */
  var getBrokenItems = function getBrokenItems(items) {
    return items.filter(function (i) {
      return i.status < 100 && i.status > 0;
    });
  };
  exportFunctions.getBrokenItems = getBrokenItems;

  /**
   * Return all of the players which have broken ships.
   * @param players
   * @returns {Array}
   */
  var getBrokenShipsPlayers = function getBrokenShipsPlayers(players) {
    return players.filter(function (p) {
      return getBrokenItems(p.shipFleet).length;
    });
  };
  exportFunctions.getBrokenShipsPlayers = getBrokenShipsPlayers;

  /**
   * Return the number of damaged ship parts. Performs math on the number of parts vs the damaged status.
   * @param total
   * @param status
   * @returns {number}
   */
  var numDamangedParts = function numDamangedParts(total, status) {
    return total - Math.ceil(status / 100 * total);
  };
  exportFunctions.numDamangedParts = numDamangedParts;

  /**
   * Used to generate 'checkerboard' style attack by only attacking every non-edge-touching cell
   * @param pnt
   * @returns {boolean}
   */
  var filterAdjacentPoints = function filterAdjacentPoints(pnt) {
    return pnt.z % 2 === 0 && (pnt.x % 2 === 0 && pnt.y % 2 === 0 || pnt.x % 2 !== 0 && pnt.y % 2 !== 0) || pnt.z % 2 !== 0 && (pnt.x % 2 !== 0 && pnt.y % 2 === 0 || pnt.x % 2 === 0 && pnt.y % 2 !== 0);
  };
  exportFunctions.filterAdjacentPoints = filterAdjacentPoints;

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser

'use strict'
// Functions used for live updating
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Store reference to any pre-existing module of the same name
   * @type {gameActions|*}
   */
  var previousGameActions = root.gameActions || {};

  /**
   * All methods exported from this module are encapsulated within gameActions.
   * @typedef {Object} gameActions
   * @property {gameActions} gameActions
   * @property {function} attackFleet
   * @property {function} attackListener
   * @property {function} computerAttack
   * @property {function} noConflict
   * @property {function} setShip
   * @property {function} updatePlayer
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {gameActions}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.gameActions = previousGameActions;
      return exportFunctions;
    }
  };
  root.gameActions = exportFunctions;

  /**
   * Verify availability of jDomCore
   * @type {*|jDomCore}
   */
  var jDomCore = root.jDomCore;

  /**
   * If gameUtils remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCore === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCore = require('./core.js');
    } else {
      console.error('actions.js requires jDomCore');
    }
  }

  /**
   * Verify availability of jDomCoreDom
   * @type {*|jDomCoreDom}
   */
  var jDomCoreDom = root.jDomCoreDom;

  /**
   * If jDomCoreDom remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCoreDom === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCoreDom = require('./core-dom.js');
    } else {
      console.error('actions.js requires jDomCoreDom');
    }
  }

  /**
   * Verify availability of jDomObjectsMatrix
   * @type {*|jDomCoreMatrix}
   */
  var jDomObjectsMatrix = root.jDomObjectsMatrix;

  /**
   * If jDomObjectsMatrix remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomObjectsMatrix === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomObjectsMatrix = require('./objects-matrix.js');
    } else {
      console.error('actions.js requires jDomObjectsMatrix');
    }
  }

  /**
   * Verify availability of jDomCoreMatrix
   * @type {*|jDomCoreMatrix}
   */
  var jDomCoreMatrix = root.jDomCoreMatrix;

  /**
   * If jDomCoreDom remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCoreMatrix === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCoreMatrix = require('./core-matrix.js');
    } else {
      console.error('actions.js requires jDomCoreMatrix');
    }
  }

  /**
   * Verify availability of jDomLayout
   * @type {*|jDomLayout}
   */
  var jDomLayout = root.jDomLayout;

  /**
   * If jDomCoreDom remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomLayout === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomLayout = require('./layout.js');
    } else {
      console.error('actions.js requires jDomLayout');
    }
  }

  /**
   * Verify availability of gamePieces
   * @type {*|gamePieces}
   */
  var gamePieces = root.gamePieces;

  /**
   * If gamePieces remains undefined, attempt to retrieve it as a module
   */
  if (typeof gamePieces === 'undefined') {
    if (typeof require !== 'undefined') {
      gamePieces = require('./game-pieces.js');
    } else {
      console.error('actions.js requires gamePieces');
    }
  }

  /**
   * Verify availability of gameUtils
   * @type {*|gameUtils}
   */
  var gameUtils = root.gameUtils;

  /**
   * If gameUtils remains undefined, attempt to retrieve it as a module
   */
  if (typeof gameUtils === 'undefined') {
    if (typeof require !== 'undefined') {
      gameUtils = require('./functions.js');
    } else {
      console.error('actions.js requires gameUtils');
    }
  }

  /**
   * Update view based on actions performed
   * @param config
   * @param isRobot
   * @returns {*}
   */
  var configureHtml = function configureHtml(config, isRobot) {
    // Update cell colour once it has been hit
    // Add any other style changes to the cell
    if (isRobot) {
      attackFleet.isLocked = true;
      jDomCore.queueTimeout(function () {
        if (config.isHit) {
          config.attributes.style.backgroundColor = config.hasShip ? 'red' : 'white';
        }
        config = jDomCoreDom.updateElement(config);
        attackFleet.isLocked = false;
        return config;
      }, 0);
    } else {
      if (config.isHit) {
        config.attributes.style.backgroundColor = config.hasShip ? 'red' : 'white';
      }
      config = jDomCoreDom.updateElement(config);
    }
    return config;
  };

  /**
   * Given a cell and new config data, update the data of the cell
   * @param config
   * @param matrix
   * @param x
   * @param y
   * @param z
   * @param isRobot
   */
  var update3dCell = function update3dCell(config, matrix, x, y, z) {
    var isRobot = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    return configureHtml(jDomCore.mergeObjectsMutable(matrix.children[z].children[y].children[x], config), isRobot);
  };

  /**
   *
   */
  var setViewShip = jDomCore.curry(update3dCell)(jDomCore.mergeObjects(gamePieces.shipTile(), { attributes: { style: { backgroundColor: '#777' } } }));

  /**
   *
   */
  var setHiddenShip = jDomCore.curry(update3dCell)(gamePieces.shipTile());

  /**
   *
   */
  var setHit = jDomCore.curry(update3dCell)(gamePieces.hitTile());

  /**
   * Set a specified point to be part of a ship
   * @param matrix
   * @param point
   * @param view
   */
  exportFunctions.setShip = function (matrix, point, view) {
    return view ? setViewShip(matrix, point.x, point.y, point.z) : setHiddenShip(matrix, point.x, point.y, point.z);
  };

  /**
   *
   * @param player
   * @param status
   * @returns {*}
   */
  var updatePlayerStats = function updatePlayerStats(player) {
    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.round(player.status * 100) / 100 + '%';

    player.playerStats = jDomCoreDom.updateElements(jDomCore.mergeObjects(player.playerStats, gamePieces.playerStats(player, status)));
    // console.log(gamePieces.playerStats(player, status).children[0].attributes.innerHTML)
    return player;
  };

  /**
   * Track player stats such as attacks and turns
   * @param player
   * @param playAgain
   * @param sunkShip
   */
  var updatePlayer = function updatePlayer(player, playAgain) {
    var sunkShip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    if (player.attacker) {
      if (playAgain) {
        ++player.attacks.hit;
      } else {
        ++player.attacks.miss;
      }
      if (sunkShip) {
        ++player.attacks.sunk;
      }
    }
    var result = {};
    if (!playAgain) {
      player.attacker = !player.attacker;
      attackFleet.isLocked = true;
      if (player.attacker) {
        result = jDomCore.queueTimeout(function () {
          attackFleet.isLocked = false;
          return player.board.children.map(function (l) {
            return l.children.map(function (r) {
              return r.children.map(function (c) {
                return jDomCoreDom.updateElement(jDomCore.mergeObjects(c, {
                  attributes: {
                    style: {
                      width: '17px',
                      height: '17px'
                    }
                  }
                }));
              });
            });
          });
        }, 100);
        ++player.turnCnt;
      } else {
        result = jDomCore.queueTimeout(function () {
          attackFleet.isLocked = false;
          return player.board.children.map(function (l) {
            return l.children.map(function (r) {
              return r.children.map(function (c) {
                return jDomCoreDom.updateElement(jDomCore.mergeObjects(c, {
                  attributes: {
                    style: {
                      width: '35px',
                      height: '35px'
                    }
                  }
                }));
              });
            });
          });
        }, 0);
      }
    }
    result = jDomCore.queueTimeout(function () {
      return updatePlayerStats(player, player.attacker ? 'ATTACKER' : Math.round(player.status * 100) / 100 + '%');
    }, 0);
    return result.result || player;
  };
  exportFunctions.updatePlayer = updatePlayer;

  /**
   * Final state once a game is won (only one player remains)
   * @param winner
   * @returns {Array.<*>}
   */
  var endGame = function endGame(winner) {
    var parent = jDomCoreDom.getTopParentItem(winner);
    var players = winner.parentItem.children;
    players.map(function (player) {
      return updatePlayerStats(player);
    });
    winner = updatePlayerStats(winner, 'WINNER');
    var finalScore = jDomCoreDom.renderHTML(jDomLayout.finalScore(players), parent);
    finalScore.children[0].children.map(function (child) {
      return jDomCore.trace('Score Card: ')(child.attributes.innerHTML);
    });
    return [winner];
  };

  /**
   *
   * @param attacker
   * @param players
   * @param attackerIndex
   * @returns {*}
   */
  var findNextAttacker = function findNextAttacker(attacker, players, attackerIndex) {
    var nextAttacker = players.length > 1 && attackerIndex >= players.length - 1 ? players[0] : players[++attackerIndex];
    return nextAttacker.status > 0 ? nextAttacker : findNextAttacker(attacker, players, attackerIndex); // Only use players with a positive status
  };

  /**
   * Based on the current attacker and list of players, return the next attacker.
   * @param attacker
   * @param players
   * @param playAgain
   * @returns {*}
   */
  var getNextAttacker = function getNextAttacker(attacker, players, playAgain) {
    return playAgain ? attacker : updatePlayer(findNextAttacker(attacker, players, players.indexOf(attacker)), playAgain);
  };

  /**
   * Update all game stats after each player round
   * @param player
   * @param hitShip
   * @param sunkShip
   * @param players
   * @returns {*}
   */
  var updateScore = function updateScore(player, hitShip, sunkShip, players) {
    players = players.filter(function (p) {
      return p.status > 0;
    });
    var attacker = players.reduce(function (p1, p2) {
      return p1.attacker ? p1 : p2;
    });
    attacker = updatePlayer(attacker, hitShip, sunkShip);
    if (players.length < 2) {
      return jDomCore.queueTimeout(function () {
        return endGame(players[0]);
      }, 200);
    }
    var nextAttacker = getNextAttacker(attacker, players, hitShip);
    if (nextAttacker.isRobot) {
      jDomCore.queueTimeout(computerAttack, 0, nextAttacker, players);
    }
    return players;
  };

  /**
   * Perform attack on an enemy board / cell
   * @param target
   * @returns {*}
   */
  var attackFleet = function attackFleet(target) {
    attackFleet.isLocked = attackFleet.isLocked || false;
    var player = jDomCoreDom.getParentsByClass('player', target)[0];
    var players = jDomCoreDom.getParentsByClass('boards', target)[0].children;
    // Player cannot attack themselves (current attacker) or if they have bad status
    if (player.status <= 0 || player.attacker || attackFleet.isLocked) {
      return players;
    }
    // Update cell to hit
    var hitCell = setHit(player.board, target.point.x, target.point.y, target.point.z, players.reduce(function (p1, p2) {
      return p1.attacker ? p1 : p2;
    }).isRobot);
    var hitShip = false;
    var sunkShip = 0;
    if (hitCell.hasShip) {
      var status = 0;
      // Update all ship status and player status by checking all ships / parts
      player.shipFleet.map(function (ship) {
        // Get all healthy ships
        var healthy = ship.parts.filter(function (part) {
          if (jDomCoreMatrix.checkEqualPoints(part.point, target.point)) {
            hitShip = ship;
          }
          return !part.isHit;
        });
        // Create percentage health status
        ship.status = healthy.length / ship.parts.length * 100;
        // Create sum of ship status
        status += ship.status;
        return ship;
      });
      // Divide sum of ship statuses by number of ships to get player status
      player.status = status / player.shipFleet.length;
    }
    if (hitShip) {
      player = updatePlayerStats(player, Math.round(player.status * 100) / 100 + '%');
      // Check if the hit ship was sunk
      sunkShip = hitShip.status <= 0 ? hitShip.parts.length : 0;
    }
    return updateScore(player, hitCell.hasShip, sunkShip, players);
  };
  exportFunctions.attackFleet = attackFleet;

  /**
   *
   * @param e
   * @param target
   * @param args
   * @returns {*}
   */
  var attackListener = function attackListener(e, target) {
    var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return attackFleet(target);
  };
  exportFunctions.attackListener = attackListener;

  /**
   * Choose which player to attack.
   * @param players
   * @returns {*}
   */
  var selectTargetPlayer = function selectTargetPlayer(players) {
    // Get a list of all players with broken ships or with lowest status.
    var victims = gameUtils.getBrokenShipsPlayers(players).length ? gameUtils.getBrokenShipsPlayers(players) : gameUtils.getLowStatusItems(players);
    // If more than one possible victim, select a random target, otherwise return the lowest status player.
    return victims.length === 1 ? victims[0] : victims[jDomCore.randomInteger(victims.length)];
  };

  /**
   * Choose which coordinate to attack.
   * @param victim
   * @returns {*}
   */
  var selectTargetCoord = function selectTargetCoord(victim) {
    // Try to get broken ships
    var brokenShips = gameUtils.getBrokenItems(victim.shipFleet);
    var availTargets = [];
    if (brokenShips.length) {
      // If there are broken ships, target those first, select the most broken ships (more than one damaged part)
      var moreBrokenShips = brokenShips.filter(function (ship) {
        return gameUtils.numDamangedParts(ship.parts.length, ship.status) > 1;
      });
      // Of the broken ships, attack the lowest status ship
      var targetShip = gameUtils.getALowStatusItem(moreBrokenShips.length ? moreBrokenShips : brokenShips);
      // Get all of the parts which have been hit
      var hitParts = targetShip.parts.filter(function (part) {
        return gameUtils.checkIfHitCell(part.point, victim.board);
      });
      if (moreBrokenShips.length) {
        // If there are more broken ships, attack the parts between hit points first.
        for (var i = 0; i < hitParts.length; ++i) {
          var targetPoints = jDomCoreMatrix.getInBetween(hitParts[0].point, hitParts[i].point, victim.board, gameUtils.checkIfHitCell, false);
          if (targetPoints.false.length) {
            displayTargets(targetPoints.false, targetPoints.false[0], victim);
            return jDomCoreMatrix.getDOMItemFromPoint(targetPoints.false[0], victim.board);
          }
        }
        // If there are no points between, attack the outer points first.
        var pntDiff = jDomCoreMatrix.pointDifference(hitParts[0].point, hitParts[1].point);
        var dirPnts = (pntDiff.x > 0 ? [jDomObjectsMatrix.point(-1, 0, 0), jDomObjectsMatrix.point(1, 0, 0)] : [jDomObjectsMatrix.point(0, -1, 0), jDomObjectsMatrix.point(0, 1, 0)]).map(function (p, i) {
          return jDomCoreMatrix.nextCell(hitParts[(hitParts.length - 1) * i].point, p);
        }).filter(function (p) {
          return jDomCoreMatrix.checkValidPoint(p, victim.board);
        }).filter(function (a) {
          return !gameUtils.checkIfHitCell(a, victim.board);
        });
        // Check outer points which are valid and not hit.
        var _target = dirPnts.reduce(function (a, b) {
          return gameUtils.checkIfHitCell(a, victim.board) ? b : a;
        });
        if (_target) {
          displayTargets(dirPnts, _target, victim);
          return jDomCoreMatrix.getDOMItemFromPoint(_target, victim.board);
        }
      }
      // If there is only one hit part, then set that as the lastTarget for detecting adjacent parts.
      availTargets = gameUtils.getAdjEdgeNonHitCells(hitParts[0].point, victim.board);
    }
    var finalTargets = availTargets.length ? availTargets : gameUtils.getAllNonHitCells(victim.board).filter(function (t) {
      return gameUtils.filterAdjacentPoints(t);
    });
    var target = finalTargets[jDomCore.randomInteger(finalTargets.length)];
    displayTargets(finalTargets, target, victim);

    // If there are available targets then hit one at random
    return jDomCoreMatrix.getDOMItemFromPoint(target, victim.board);
  };

  /**
   *
   * @param targets
   * @param target
   * @param victim
   * @returns {[*,*]}
   */
  var displayTargets = function displayTargets(targets, target, victim) {
    return [jDomCore.queueTimeout(resetTargets, 0, { targets: targets, victim: victim }), jDomCore.queueTimeout(resetTargets, 200, { targets: targets, target: target, victim: victim })];
  };

  /**
   *
   * @param data
   * @returns {void|Array|Object|*}
   */
  var resetTargets = function resetTargets(data) {
    data.victim.board.children.map(function (l) {
      return jDomCoreDom.updateElement(jDomCore.mergeObjects(l, { attributes: { style: { borderColor: '#333' } } }));
    });
    data.targets.forEach(function (t) {
      return jDomCoreDom.updateElement(jDomCore.mergeObjects(jDomCoreMatrix.getDOMItemFromPoint(t, data.victim.board), { attributes: { style: { borderColor: '#333' } } }));
    });
    if (!data.target) {
      data.victim.board.children.map(function (l) {
        return jDomCoreDom.updateElement(jDomCore.mergeObjects(l, { attributes: { style: { borderColor: 'yellow' } } }));
      });
      data.targets.forEach(function (t) {
        return jDomCoreDom.updateElement(jDomCore.mergeObjects(jDomCoreMatrix.getDOMItemFromPoint(t, data.victim.board), { attributes: { style: { borderColor: 'yellow' } } }));
      });
    }
    return data;
  };

  /**
   * Main AI logic for computer to attack, selects a target then performs attack function.
   * @param player
   * @param players
   */
  var computerAttack = function computerAttack(player, players) {
    var victim = selectTargetPlayer(players.filter(function (p) {
      return !p.attacker;
    }));
    attackFleet.isLocked = false;
    return attackFleet(selectTargetCoord(victim));
  };
  exportFunctions.computerAttack = computerAttack;

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser

'use strict'
// Game specific functions
;(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Store reference to any pre-existing module of the same name
   * @type {gameStart|*}
   */
  var previousGameStart = root.gameStart || {};

  /**
   * All methods exported from this module are encapsulated within gameStart.
   * @typedef {Object} gameStart
   * @property {gameStart} gameStart
   * @property {function} beginRound
   * @property {function} main
   * @property {function} noConflict
   * @property {function} restart
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {gameUtils}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.gameStart = previousGameStart;
      return exportFunctions;
    }
  };
  root.gameStart = exportFunctions;

  /**
   * Verify availability of jDomCore
   * @type {*|jDomCore}
   */
  var jDomCore = root.jDomCore;

  /**
   * If jDomCore remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCore === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCore = require('./core.js');
    } else {
      console.error('start-functions.js requires jDomCore');
    }
  }

  /**
   * Verify availability of jDomObjects
   * @type {*|jDomObjects}
   */
  var jDomObjects = root.jDomObjects;

  /**
   * If jDomObjects remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomObjects === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomObjects = require('./objects-dom.js');
    } else {
      console.error('start-functions.js requires jDomObjects');
    }
  }

  /**
   * Verify availability of jDomCoreDom
   * @type {*|jDomCoreDom}
   */
  var jDomCoreDom = root.jDomCoreDom;

  /**
   * If jDomCoreDom remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCoreDom === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCoreDom = require('./core-dom.js');
    } else {
      console.error('start-functions.js requires jDomCoreDom');
    }
  }

  /**
   * Verify availability of jDomCoreMatrix
   * @type {*|jDomCoreMatrix}
   */
  var jDomCoreMatrix = root.jDomCoreMatrix;

  /**
   * If jDomCoreMatrix remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCoreMatrix === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCoreMatrix = require('./core-matrix.js');
    } else {
      console.error('start-functions.js requires jDomCoreMatrix');
    }
  }

  /**
   * Verify availability of jDomObjectsMatrix
   * @type {*|jDomCoreMatrix}
   */
  var jDomObjectsMatrix = root.jDomObjectsMatrix;

  /**
   * If jDomObjectsMatrix remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomObjectsMatrix === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomObjectsMatrix = require('./objects-matrix.js');
    } else {
      console.error('start-functions.js requires jDomObjectsMatrix');
    }
  }

  /**
   * Verify availability of jDomLayout
   * @type {*|jDomLayout}
   */
  var jDomLayout = root.jDomLayout;

  /**
   * If jDomLayout remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomLayout === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomLayout = require('./layout.js');
    } else {
      console.error('start-functions.js requires jDomLayout');
    }
  }

  /**
   * Verify availability of gamePieces
   * @type {*|gamePieces}
   */
  var gamePieces = root.gamePieces;

  /**
   * If gameUtils remains undefined, attempt to retrieve it as a module
   */
  if (typeof gamePieces === 'undefined') {
    if (typeof require !== 'undefined') {
      gamePieces = require('./game-pieces.js');
    } else {
      console.error('start-functions.js requires gamePieces');
    }
  }

  /**
   * Verify availability of gameUtils
   * @type {*|gameUtils}
   */
  var gameUtils = root.gameUtils;

  /**
   * If gameUtils remains undefined, attempt to retrieve it as a module
   */
  if (typeof gameUtils === 'undefined') {
    if (typeof require !== 'undefined') {
      gameUtils = require('./functions.js');
    } else {
      console.error('start-functions.js requires gameUtils');
    }
  }

  /**
   * Verify availability of gameActions
   * @type {*|gameActions}
   */
  var gameActions = root.gameActions;

  /**
   * If gameActions remains undefined, attempt to retrieve it as a module
   */
  if (typeof gameActions === 'undefined') {
    if (typeof require !== 'undefined') {
      gameActions = require('./actions.js');
    } else {
      console.error('start-functions.js requires gameActions');
    }
  }

  /**
   * Generate a ship with the provided line of points.
   * The visibility of the ship on the board is determined by the view parameter.
   * @param shipInfo
   * @param line
   * @param matrix
   * @param view
   * @returns {{name: string, status: number, parts: Array}}
   */
  var buildShip = function buildShip(shipInfo, line, matrix) {
    var view = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    return jDomCore.mergeObjects(gamePieces.ship(shipInfo.name), { parts: line.map(function (p) {
        return gameActions.setShip(matrix, p, view);
      }) });
  };

  /**
   *
   * @param lengths
   * @param shipLength
   */
  var selectShipDirection = function selectShipDirection(lengths, shipLength) {
    return jDomCoreMatrix.randDirection([jDomObjectsMatrix.point(1, 0, 0), jDomObjectsMatrix.point(0, 1, 0), jDomObjectsMatrix.point(0, 0, 1)].filter(function (p) {
      return lengths[jDomCoreMatrix.getAxisOfCoord(p, 1)] > shipLength;
    }));
  };

  /**
   *
   * @param lengths
   * @param shipLength
   * @param dir
   * @returns {{start: {x: number, y: number, z: number}, dir}}
   */
  var randomStartDir = function randomStartDir(lengths, shipLength) {
    var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : selectShipDirection(lengths, shipLength);
    return {
      start: jDomCoreMatrix.randomStart(shipLength, dir, lengths),
      dir: dir
    };
  };

  /**
   * Get a qualifying start and direction point for a ship of specified length
   * WARNING: This is a recursive function.
   * @param matrix
   * @param shipLength
   * @param lengths
   * @param startDir
   * @returns {[null,null]}
   */
  var generateStartEnd = function generateStartEnd(matrix, shipLength, lengths) {
    var _jDomCoreMatrix;

    var startDir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : randomStartDir(lengths, shipLength);
    return jDomCoreMatrix.getHighAbsoluteCoord(startDir.dir) === 0 ? [jDomObjectsMatrix.point(0, 0, 0), jDomObjectsMatrix.point(0, 0, 0)] : (_jDomCoreMatrix = jDomCoreMatrix).checkInBetween.apply(_jDomCoreMatrix, [startDir.start, jDomCoreMatrix.lineEndPoint(startDir.start, shipLength, startDir.dir)].concat([matrix, gameUtils.checkIfShipCell])) ? generateStartEnd(matrix, shipLength, lengths) : [startDir.start, jDomCoreMatrix.lineEndPoint(startDir.start, shipLength, startDir.dir)];
  };

  /**
   * Create a series of randomly placed ships based on the provided shipLengths.
   * The optional parameter view will set the visibility of the ships.
   * @param {Array} ships
   * @param {Object} matrix
   * @param {boolean} [view=false]
   * @returns {Array}
   */
  var generateRandomFleet = function generateRandomFleet(ships, matrix) {
    var view = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return ships.map(function (ship) {
      var _jDomCoreMatrix2;

      return buildShip(ship, (_jDomCoreMatrix2 = jDomCoreMatrix).getPointsLine.apply(_jDomCoreMatrix2, _toConsumableArray(generateStartEnd(matrix, ship.size, jDomCoreMatrix.getAxisLengths(matrix)))), matrix, view);
    });
  };

  /**
   * Create a default fleet using the standard battleship lengths.
   * @type {Array}
   */
  var defaultFleet = jDomCore.curry(generateRandomFleet)([{ name: 'Aircraft Carrier', size: 5 }, { name: 'Battleship', size: 4 }, { name: 'Submarine', size: 3 }, { name: 'Cruiser', size: 3 }, { name: 'Destroyer', size: 2 }]);

  /**
   * Create players and associated properties.
   * Takes an integer for the number of players to generate.
   * Returns an array of players.
   * WARNING: This is a recursive function.
   * @param humans
   * @param robots
   * @param players
   * @returns {Array}
   */
  var buildPlayers = function buildPlayers(humans) {
    var robots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var players = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    if (humans < 1 && robots < 1) {
      return players;
    }
    var player = gamePieces.playerSet({}, 'Player ' + (players.length + 1));
    player.isRobot = humans <= 0;
    player.board = jDomCoreMatrix.bindPointData(jDomObjectsMatrix.square(gamePieces.waterTile(player, players), 10));
    player.shipFleet = defaultFleet(player.board, false); // generate fleet of ships
    player.playerStats = gamePieces.playerStats(player, Math.round(player.status * 100) / 100 + '%');
    player.children = [player.board, player.playerStats];
    players.push(player);
    return buildPlayers(--humans, humans < 0 ? --robots : robots, players);
  };

  /**
   * Logic for setting up and starting a new round
   * (selects random start player and calls computer attack if it is AI starting)
   * @param e
   * @param mainForm
   * @returns {boolean}
   */
  exportFunctions.beginRound = function (e, mainForm) {
    e.preventDefault();
    var parent = jDomCoreDom.getTopParentItem(mainForm);
    var humans = parseInt(jDomCoreDom.getChildrenByName('human-players', mainForm)[0].element.value);
    var robots = parseInt(jDomCoreDom.getChildrenByName('robot-players', mainForm)[0].element.value);
    if (humans < 0 || humans > 100 || robots < 0 || robots > 100) {
      return false;
    }
    var firstGoesFirst = jDomCoreDom.getChildrenByName('first-go-first', mainForm)[0].element.checked;
    humans = humans < 0 ? 0 : humans;
    if (humans === 0) {
      robots = robots < 2 ? 2 : robots;
    }
    if (humans === 1) {
      robots = robots < 1 ? 1 : robots;
    }
    jDomCoreDom.removeChild(jDomCoreDom.getChildrenByClass('main-menu', parent.body)[0], parent.body);
    var players = jDomCoreDom.renderHTML(jDomLayout.boards(buildPlayers(humans, robots)), parent).children;
    var firstAttacker = gameActions.updatePlayer(firstGoesFirst ? players[0] : players[jDomCore.randomInteger(players.length)]);
    if (firstAttacker.isRobot) {
      gameActions.computerAttack(firstAttacker, players);
    }
    return false;
  };

  /**
   * The entry function
   * @param parent
   */
  var main = function main() {
    var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : jDomObjects.documentItem;

    for (var i = parent.body.children.length - 1; i >= 0; --i) {
      jDomCoreDom.removeChild(parent.body.children[i], parent.body);
    }
    jDomCoreDom.renderHTML(jDomLayout.mainMenu(), parent);
    return parent;
  };
  exportFunctions.main = main;

  exportFunctions.restart = function (e, button) {
    return main(jDomCoreDom.getTopParentItem(button));
  };

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser

'use strict';(function () {
  /**
   * Store a reference to this scope which will be Window if rendered via browser
   */
  var root = this || {};

  /**
   * Store reference to any pre-existing module of the same name
   * @type {gameMain|*}
   */
  var previousGameMain = root.gameMain || {};

  /**
   * All methods exported from this module are encapsulated within gameMain.
   * @typedef {Object} gameMain
   * @property {gameMain} gameMain
   * @property {function} noConflict
   */

  /**
   * A reference to all functions to be used globally / exported
   * @type {gameMain}
   */
  var exportFunctions = {
    noConflict: function noConflict() {
      root.gameMain = previousGameMain;
      return exportFunctions;
    }
  };
  root.gameMain = exportFunctions;

  /**
   * Verify availability of jDomObjects
   * @type {*|jDomObjects}
   */
  var jDomObjects = root.jDomObjects;

  /**
   * If jDomObjects remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomObjects === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomObjects = require('./objects-dom.js');
    } else {
      console.error('main.js requires jDomObjects');
    }
  }

  /**
   * Verify availability of jDomCoreDom
   * @type {*|jDomCoreDom}
   */
  var jDomCoreDom = root.jDomCoreDom;

  /**
   * If jDomCoreDom remains undefined, attempt to retrieve it as a module
   */
  if (typeof jDomCoreDom === 'undefined') {
    if (typeof require !== 'undefined') {
      jDomCoreDom = require('./core-dom.js');
    } else {
      console.error('main.js requires jDomCoreDom');
    }
  }

  /**
   * Verify availability of gameActions
   * @type {*|gameActions}
   */
  var gameActions = root.gameActions;

  /**
   * If gameUtils remains undefined, attempt to retrieve it as a module
   */
  if (typeof gameActions === 'undefined') {
    if (typeof require !== 'undefined') {
      gameActions = require('./actions.js');
    } else {
      console.error('main.js requires gameActions');
    }
  }

  /**
   * Verify availability of gameStart
   * @type {*|gameStart}
   */
  var gameStart = root.gameStart;

  /**
   * If jDomCoreDom remains undefined, attempt to retrieve it as a module
   */
  if (typeof gameStart === 'undefined') {
    if (typeof require !== 'undefined') {
      gameStart = require('./start-functions.js');
    } else {
      console.error('main.js requires gameStart');
    }
  }

  /**
   * Create new private reference to the document
   */
  var documentItem = gameStart.main(jDomObjects.documentDOMItem({
    beginRound: gameStart.beginRound,
    attackListener: gameActions.attackListener,
    restart: gameStart.restart
  }));
  console.log(documentItem);

  // const div = jDomCoreDom.getChildrenByClass('main-menu', documentItem.body)
  // console.log(div[0].element)
  // const form = jDomCoreDom.getChildrenByClass('main-menu-form', documentItem.body)
  // console.log(form[0].element)
  // form[0].element.submit()
  // const submitBtn = jDomCoreDom.getChildrenFromAttribute('type', 'submit', form[0])
  // console.log(submitBtn[0].element)
  // submitBtn[0].element.click()

  // samples expanded from https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge#new-answer
  // let results = mergeObjects({
  //     a: { a: 1},
  // },{
  //     a: { b: 1},
  // },{
  //     a: { b: 2, c: 1},
  //     b: 2,
  // })
  // console.log(results)

  /**
   * Either export all functions to be exported, or assign to the Window context
   */
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = exportFunctions;
    }
    exports = Object.assign(exports, exportFunctions);
  }
}).call(undefined || window || base || {}); // Use the external context to assign this, which will be Window if rendered via browser